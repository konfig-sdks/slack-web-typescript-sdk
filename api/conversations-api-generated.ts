/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ConversationsArchiveRequest } from '../models';
// @ts-ignore
import { ConversationsArchiveResponse } from '../models';
// @ts-ignore
import { ConversationsArchivedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsCloseRequest } from '../models';
// @ts-ignore
import { ConversationsCloseResponse } from '../models';
// @ts-ignore
import { ConversationsClosedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsCreateRequest } from '../models';
// @ts-ignore
import { ConversationsCreateResponse } from '../models';
// @ts-ignore
import { ConversationsCreatedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsHistoryResponse } from '../models';
// @ts-ignore
import { ConversationsHistorydefaultResponse } from '../models';
// @ts-ignore
import { ConversationsInfoResponse } from '../models';
// @ts-ignore
import { ConversationsInfodefaultResponse } from '../models';
// @ts-ignore
import { ConversationsInviteRequest } from '../models';
// @ts-ignore
import { ConversationsInviteResponse } from '../models';
// @ts-ignore
import { ConversationsInvitedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsJoinRequest } from '../models';
// @ts-ignore
import { ConversationsJoinResponse } from '../models';
// @ts-ignore
import { ConversationsJoindefaultResponse } from '../models';
// @ts-ignore
import { ConversationsKickRequest } from '../models';
// @ts-ignore
import { ConversationsKickResponse } from '../models';
// @ts-ignore
import { ConversationsKickdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsLeaveRequest } from '../models';
// @ts-ignore
import { ConversationsLeaveResponse } from '../models';
// @ts-ignore
import { ConversationsLeavedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsListResponse } from '../models';
// @ts-ignore
import { ConversationsListdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsMarkRequest } from '../models';
// @ts-ignore
import { ConversationsMarkResponse } from '../models';
// @ts-ignore
import { ConversationsMarkdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsMembersResponse } from '../models';
// @ts-ignore
import { ConversationsMembersdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsOpenRequest } from '../models';
// @ts-ignore
import { ConversationsOpenResponse } from '../models';
// @ts-ignore
import { ConversationsOpendefaultResponse } from '../models';
// @ts-ignore
import { ConversationsRenameRequest } from '../models';
// @ts-ignore
import { ConversationsRenameResponse } from '../models';
// @ts-ignore
import { ConversationsRenamedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsRepliesResponse } from '../models';
// @ts-ignore
import { ConversationsRepliesdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsSetPurposeRequest } from '../models';
// @ts-ignore
import { ConversationsSetPurposeResponse } from '../models';
// @ts-ignore
import { ConversationsSetPurposedefaultResponse } from '../models';
// @ts-ignore
import { ConversationsSetTopicRequest } from '../models';
// @ts-ignore
import { ConversationsSetTopicResponse } from '../models';
// @ts-ignore
import { ConversationsSetTopicdefaultResponse } from '../models';
// @ts-ignore
import { ConversationsUnarchiveRequest } from '../models';
// @ts-ignore
import { ConversationsUnarchiveResponse } from '../models';
// @ts-ignore
import { ConversationsUnarchivedefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] ID of conversation to archive
         * @param {ConversationsArchiveRequest} [conversationsArchiveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive: async (token?: string, channel?: string, conversationsArchiveRequest?: ConversationsArchiveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsArchiveRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.archive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsArchiveRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Closes a direct message or multi-person direct message.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Conversation to close.
         * @param {ConversationsCloseRequest} [conversationsCloseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close: async (token?: string, channel?: string, conversationsCloseRequest?: ConversationsCloseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsCloseRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.close',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsCloseRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a public or private channel-based conversation
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {boolean} [isPrivate] Create a private channel instead of a public one
         * @param {string} [name] Name of the public or private channel to create
         * @param {ConversationsCreateRequest} [conversationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (token?: string, isPrivate?: boolean, name?: string, conversationsCreateRequest?: ConversationsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (isPrivate !== undefined) {
                await addFormParam('is_private', isPrivate, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.create',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a conversation\'s history of messages and events.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:history&#x60;
         * @param {string} [channel] Conversation ID to fetch history for.
         * @param {number} [latest] End of time range of messages to include in results.
         * @param {number} [oldest] Start of time range of messages to include in results.
         * @param {boolean} [inclusive] Include messages with latest or oldest timestamp in results only when either timestamp is specified.
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\&#39;t been reached.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history: async (token?: string, channel?: string, latest?: number, oldest?: number, inclusive?: boolean, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:history", "groups:history", "im:history", "mpim:history"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (oldest !== undefined) {
                localVarQueryParameter['oldest'] = oldest;
            }

            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.history',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:read&#x60;
         * @param {string} [channel] Conversation ID to learn more about
         * @param {boolean} [includeLocale] Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60;
         * @param {boolean} [includeNumMembers] Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (token?: string, channel?: string, includeLocale?: boolean, includeNumMembers?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:read", "groups:read", "im:read", "mpim:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (includeLocale !== undefined) {
                localVarQueryParameter['include_locale'] = includeLocale;
            }

            if (includeNumMembers !== undefined) {
                localVarQueryParameter['include_num_members'] = includeNumMembers;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invites users to a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] The ID of the public or private channel to invite user(s) to.
         * @param {string} [users] A comma separated list of user IDs. Up to 1000 users may be listed.
         * @param {ConversationsInviteRequest} [conversationsInviteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite: async (token?: string, channel?: string, users?: string, conversationsInviteRequest?: ConversationsInviteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (users !== undefined) {
                await addFormParam('users', users, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsInviteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.invite',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsInviteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Joins an existing conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;channels:write&#x60;
         * @param {string} [channel] ID of conversation to join
         * @param {ConversationsJoinRequest} [conversationsJoinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        join: async (token?: string, channel?: string, conversationsJoinRequest?: ConversationsJoinRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsJoinRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.join',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsJoinRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a user from a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] ID of conversation to remove user from.
         * @param {string} [user] User ID to be removed.
         * @param {ConversationsKickRequest} [conversationsKickRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick: async (token?: string, channel?: string, user?: string, conversationsKickRequest?: ConversationsKickRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.kick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (user !== undefined) {
                await addFormParam('user', user, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsKickRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.kick',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsKickRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Leaves a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Conversation to leave
         * @param {ConversationsLeaveRequest} [conversationsLeaveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leave: async (token?: string, channel?: string, conversationsLeaveRequest?: ConversationsLeaveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.leave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsLeaveRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.leave',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsLeaveRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all channels in a Slack team.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:read&#x60;
         * @param {boolean} [excludeArchived] Set to &#x60;true&#x60; to exclude archived channels from the list
         * @param {string} [types] Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60;
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\&#39;t been reached. Must be an integer no larger than 1000.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (token?: string, excludeArchived?: boolean, types?: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:read", "groups:read", "im:read", "mpim:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (excludeArchived !== undefined) {
                localVarQueryParameter['exclude_archived'] = excludeArchived;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the read cursor in a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Channel or conversation to set the read cursor for.
         * @param {number} [ts] Unique identifier of message you want marked as most recently seen in this conversation.
         * @param {ConversationsMarkRequest} [conversationsMarkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mark: async (token?: string, channel?: string, ts?: number, conversationsMarkRequest?: ConversationsMarkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.mark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (ts !== undefined) {
                await addFormParam('ts', ts, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsMarkRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.mark',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsMarkRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve members of a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:read&#x60;
         * @param {string} [channel] ID of the conversation to retrieve members for
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\&#39;t been reached.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        members: async (token?: string, channel?: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:read", "groups:read", "im:read", "mpim:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.members',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Opens or resumes a direct message or multi-person direct message.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;\\\&#39;s ID. Or provide the &#x60;users&#x60; field instead.
         * @param {boolean} [returnIm] Boolean, indicates you want the full IM channel definition in the response.
         * @param {string} [users] Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;.
         * @param {ConversationsOpenRequest} [conversationsOpenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        open: async (token?: string, channel?: string, returnIm?: boolean, users?: string, conversationsOpenRequest?: ConversationsOpenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (returnIm !== undefined) {
                await addFormParam('return_im', returnIm, false, true)
            }
    
            if (users !== undefined) {
                await addFormParam('users', users, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsOpenRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.open',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsOpenRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] ID of conversation to rename
         * @param {string} [name] New name for conversation.
         * @param {ConversationsRenameRequest} [conversationsRenameRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename: async (token?: string, channel?: string, name?: string, conversationsRenameRequest?: ConversationsRenameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsRenameRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.rename',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsRenameRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a thread of messages posted to a conversation
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:history&#x60;
         * @param {string} [channel] Conversation ID to fetch thread from.
         * @param {number} [ts] Unique identifier of a thread\&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message.
         * @param {number} [latest] End of time range of messages to include in results.
         * @param {number} [oldest] Start of time range of messages to include in results.
         * @param {boolean} [inclusive] Include messages with latest or oldest timestamp in results only when either timestamp is specified.
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\&#39;t been reached.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replies: async (token?: string, channel?: string, ts?: number, latest?: number, oldest?: number, inclusive?: boolean, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.replies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:history", "groups:history", "im:history", "mpim:history"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (oldest !== undefined) {
                localVarQueryParameter['oldest'] = oldest;
            }

            if (inclusive !== undefined) {
                localVarQueryParameter['inclusive'] = inclusive;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.replies',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the purpose for a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Conversation to set the purpose of
         * @param {string} [purpose] A new, specialer purpose
         * @param {ConversationsSetPurposeRequest} [conversationsSetPurposeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPurpose: async (token?: string, channel?: string, purpose?: string, conversationsSetPurposeRequest?: ConversationsSetPurposeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.setPurpose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (purpose !== undefined) {
                await addFormParam('purpose', purpose, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsSetPurposeRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.setPurpose',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsSetPurposeRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the topic for a conversation.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] Conversation to set the topic of
         * @param {string} [topic] The new topic string. Does not support formatting or linkification.
         * @param {ConversationsSetTopicRequest} [conversationsSetTopicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTopic: async (token?: string, channel?: string, topic?: string, conversationsSetTopicRequest?: ConversationsSetTopicRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.setTopic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (topic !== undefined) {
                await addFormParam('topic', topic, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsSetTopicRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.setTopic',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsSetTopicRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reverses conversation archival.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:write&#x60;
         * @param {string} [channel] ID of conversation to unarchive
         * @param {ConversationsUnarchiveRequest} [conversationsUnarchiveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchive: async (token?: string, channel?: string, conversationsUnarchiveRequest?: ConversationsUnarchiveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations.unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:write", "groups:write", "im:write", "mpim:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsUnarchiveRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations.unarchive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsUnarchiveRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Archives a conversation.
         * @param {ConversationsApiArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archive(requestParameters: ConversationsApiArchiveRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsArchiveResponse>> {
            const conversationsArchiveRequest: ConversationsArchiveRequest = {
                channel: requestParameters.channel
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.archive(requestParameters.token, requestParameters.channel, conversationsArchiveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Closes a direct message or multi-person direct message.
         * @param {ConversationsApiCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async close(requestParameters: ConversationsApiCloseRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsCloseResponse>> {
            const conversationsCloseRequest: ConversationsCloseRequest = {
                channel: requestParameters.channel
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.close(requestParameters.token, requestParameters.channel, conversationsCloseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiates a public or private channel-based conversation
         * @param {ConversationsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(requestParameters: ConversationsApiCreateRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsCreateResponse>> {
            const conversationsCreateRequest: ConversationsCreateRequest = {
                is_private: requestParameters.is_private,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(requestParameters.token, requestParameters.isPrivate, requestParameters.name, conversationsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches a conversation\'s history of messages and events.
         * @param {ConversationsApiHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async history(requestParameters: ConversationsApiHistoryRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.history(requestParameters.token, requestParameters.channel, requestParameters.latest, requestParameters.oldest, requestParameters.inclusive, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a conversation.
         * @param {ConversationsApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(requestParameters: ConversationsApiInfoRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(requestParameters.token, requestParameters.channel, requestParameters.includeLocale, requestParameters.includeNumMembers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invites users to a channel.
         * @param {ConversationsApiInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invite(requestParameters: ConversationsApiInviteRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsInviteResponse>> {
            const conversationsInviteRequest: ConversationsInviteRequest = {
                channel: requestParameters.channel,
                users: requestParameters.users
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.invite(requestParameters.token, requestParameters.channel, requestParameters.users, conversationsInviteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Joins an existing conversation.
         * @param {ConversationsApiJoinRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async join(requestParameters: ConversationsApiJoinRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsJoinResponse>> {
            const conversationsJoinRequest: ConversationsJoinRequest = {
                channel: requestParameters.channel
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.join(requestParameters.token, requestParameters.channel, conversationsJoinRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a user from a conversation.
         * @param {ConversationsApiKickRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kick(requestParameters: ConversationsApiKickRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsKickResponse>> {
            const conversationsKickRequest: ConversationsKickRequest = {
                channel: requestParameters.channel,
                user: requestParameters.user
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.kick(requestParameters.token, requestParameters.channel, requestParameters.user, conversationsKickRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Leaves a conversation.
         * @param {ConversationsApiLeaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leave(requestParameters: ConversationsApiLeaveRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsLeaveResponse>> {
            const conversationsLeaveRequest: ConversationsLeaveRequest = {
                channel: requestParameters.channel
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.leave(requestParameters.token, requestParameters.channel, conversationsLeaveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all channels in a Slack team.
         * @param {ConversationsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: ConversationsApiListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.token, requestParameters.excludeArchived, requestParameters.types, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the read cursor in a channel.
         * @param {ConversationsApiMarkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mark(requestParameters: ConversationsApiMarkRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsMarkResponse>> {
            const conversationsMarkRequest: ConversationsMarkRequest = {
                channel: requestParameters.channel,
                ts: requestParameters.ts
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.mark(requestParameters.token, requestParameters.channel, requestParameters.ts, conversationsMarkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve members of a conversation.
         * @param {ConversationsApiMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async members(requestParameters: ConversationsApiMembersRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.members(requestParameters.token, requestParameters.channel, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Opens or resumes a direct message or multi-person direct message.
         * @param {ConversationsApiOpenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async open(requestParameters: ConversationsApiOpenRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsOpenResponse>> {
            const conversationsOpenRequest: ConversationsOpenRequest = {
                channel: requestParameters.channel,
                return_im: requestParameters.return_im,
                users: requestParameters.users
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.open(requestParameters.token, requestParameters.channel, requestParameters.returnIm, requestParameters.users, conversationsOpenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Renames a conversation.
         * @param {ConversationsApiRenameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rename(requestParameters: ConversationsApiRenameRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsRenameResponse>> {
            const conversationsRenameRequest: ConversationsRenameRequest = {
                channel: requestParameters.channel,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.rename(requestParameters.token, requestParameters.channel, requestParameters.name, conversationsRenameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a thread of messages posted to a conversation
         * @param {ConversationsApiRepliesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replies(requestParameters: ConversationsApiRepliesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsRepliesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replies(requestParameters.token, requestParameters.channel, requestParameters.ts, requestParameters.latest, requestParameters.oldest, requestParameters.inclusive, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the purpose for a conversation.
         * @param {ConversationsApiSetPurposeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPurpose(requestParameters: ConversationsApiSetPurposeRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsSetPurposeResponse>> {
            const conversationsSetPurposeRequest: ConversationsSetPurposeRequest = {
                channel: requestParameters.channel,
                purpose: requestParameters.purpose
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPurpose(requestParameters.token, requestParameters.channel, requestParameters.purpose, conversationsSetPurposeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the topic for a conversation.
         * @param {ConversationsApiSetTopicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTopic(requestParameters: ConversationsApiSetTopicRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsSetTopicResponse>> {
            const conversationsSetTopicRequest: ConversationsSetTopicRequest = {
                channel: requestParameters.channel,
                topic: requestParameters.topic
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTopic(requestParameters.token, requestParameters.channel, requestParameters.topic, conversationsSetTopicRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reverses conversation archival.
         * @param {ConversationsApiUnarchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchive(requestParameters: ConversationsApiUnarchiveRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsUnarchiveResponse>> {
            const conversationsUnarchiveRequest: ConversationsUnarchiveRequest = {
                channel: requestParameters.channel
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchive(requestParameters.token, requestParameters.channel, conversationsUnarchiveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Archives a conversation.
         * @param {ConversationsApiArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archive(requestParameters: ConversationsApiArchiveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsArchiveResponse> {
            return localVarFp.archive(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Closes a direct message or multi-person direct message.
         * @param {ConversationsApiCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close(requestParameters: ConversationsApiCloseRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsCloseResponse> {
            return localVarFp.close(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a public or private channel-based conversation
         * @param {ConversationsApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ConversationsApiCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsCreateResponse> {
            return localVarFp.create(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a conversation\'s history of messages and events.
         * @param {ConversationsApiHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history(requestParameters: ConversationsApiHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsHistoryResponse> {
            return localVarFp.history(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a conversation.
         * @param {ConversationsApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(requestParameters: ConversationsApiInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsInfoResponse> {
            return localVarFp.info(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Invites users to a channel.
         * @param {ConversationsApiInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invite(requestParameters: ConversationsApiInviteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsInviteResponse> {
            return localVarFp.invite(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Joins an existing conversation.
         * @param {ConversationsApiJoinRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        join(requestParameters: ConversationsApiJoinRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsJoinResponse> {
            return localVarFp.join(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a user from a conversation.
         * @param {ConversationsApiKickRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick(requestParameters: ConversationsApiKickRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsKickResponse> {
            return localVarFp.kick(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Leaves a conversation.
         * @param {ConversationsApiLeaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leave(requestParameters: ConversationsApiLeaveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsLeaveResponse> {
            return localVarFp.leave(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all channels in a Slack team.
         * @param {ConversationsApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ConversationsApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the read cursor in a channel.
         * @param {ConversationsApiMarkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mark(requestParameters: ConversationsApiMarkRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsMarkResponse> {
            return localVarFp.mark(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve members of a conversation.
         * @param {ConversationsApiMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        members(requestParameters: ConversationsApiMembersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsMembersResponse> {
            return localVarFp.members(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Opens or resumes a direct message or multi-person direct message.
         * @param {ConversationsApiOpenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        open(requestParameters: ConversationsApiOpenRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsOpenResponse> {
            return localVarFp.open(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames a conversation.
         * @param {ConversationsApiRenameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(requestParameters: ConversationsApiRenameRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsRenameResponse> {
            return localVarFp.rename(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a thread of messages posted to a conversation
         * @param {ConversationsApiRepliesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replies(requestParameters: ConversationsApiRepliesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsRepliesResponse> {
            return localVarFp.replies(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the purpose for a conversation.
         * @param {ConversationsApiSetPurposeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPurpose(requestParameters: ConversationsApiSetPurposeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsSetPurposeResponse> {
            return localVarFp.setPurpose(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the topic for a conversation.
         * @param {ConversationsApiSetTopicRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTopic(requestParameters: ConversationsApiSetTopicRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsSetTopicResponse> {
            return localVarFp.setTopic(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Reverses conversation archival.
         * @param {ConversationsApiUnarchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchive(requestParameters: ConversationsApiUnarchiveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationsUnarchiveResponse> {
            return localVarFp.unarchive(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archive operation in ConversationsApi.
 * @export
 * @interface ConversationsApiArchiveRequest
 */
export type ConversationsApiArchiveRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiArchive
    */
    readonly token?: string
    
    /**
    * ID of conversation to archive
    * @type {string}
    * @memberof ConversationsApiArchive
    */
    readonly channel?: string
    
} & ConversationsArchiveRequest

/**
 * Request parameters for close operation in ConversationsApi.
 * @export
 * @interface ConversationsApiCloseRequest
 */
export type ConversationsApiCloseRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiClose
    */
    readonly token?: string
    
    /**
    * Conversation to close.
    * @type {string}
    * @memberof ConversationsApiClose
    */
    readonly channel?: string
    
} & ConversationsCloseRequest

/**
 * Request parameters for create operation in ConversationsApi.
 * @export
 * @interface ConversationsApiCreateRequest
 */
export type ConversationsApiCreateRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiCreate
    */
    readonly token?: string
    
    /**
    * Create a private channel instead of a public one
    * @type {boolean}
    * @memberof ConversationsApiCreate
    */
    readonly isPrivate?: boolean
    
    /**
    * Name of the public or private channel to create
    * @type {string}
    * @memberof ConversationsApiCreate
    */
    readonly name?: string
    
} & ConversationsCreateRequest

/**
 * Request parameters for history operation in ConversationsApi.
 * @export
 * @interface ConversationsApiHistoryRequest
 */
export type ConversationsApiHistoryRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:history`
    * @type {string}
    * @memberof ConversationsApiHistory
    */
    readonly token?: string
    
    /**
    * Conversation ID to fetch history for.
    * @type {string}
    * @memberof ConversationsApiHistory
    */
    readonly channel?: string
    
    /**
    * End of time range of messages to include in results.
    * @type {number}
    * @memberof ConversationsApiHistory
    */
    readonly latest?: number
    
    /**
    * Start of time range of messages to include in results.
    * @type {number}
    * @memberof ConversationsApiHistory
    */
    readonly oldest?: number
    
    /**
    * Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    * @type {boolean}
    * @memberof ConversationsApiHistory
    */
    readonly inclusive?: boolean
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\'t been reached.
    * @type {number}
    * @memberof ConversationsApiHistory
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ConversationsApiHistory
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for info operation in ConversationsApi.
 * @export
 * @interface ConversationsApiInfoRequest
 */
export type ConversationsApiInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:read`
    * @type {string}
    * @memberof ConversationsApiInfo
    */
    readonly token?: string
    
    /**
    * Conversation ID to learn more about
    * @type {string}
    * @memberof ConversationsApiInfo
    */
    readonly channel?: string
    
    /**
    * Set this to `true` to receive the locale for this conversation. Defaults to `false`
    * @type {boolean}
    * @memberof ConversationsApiInfo
    */
    readonly includeLocale?: boolean
    
    /**
    * Set to `true` to include the member count for the specified conversation. Defaults to `false`
    * @type {boolean}
    * @memberof ConversationsApiInfo
    */
    readonly includeNumMembers?: boolean
    
}

/**
 * Request parameters for invite operation in ConversationsApi.
 * @export
 * @interface ConversationsApiInviteRequest
 */
export type ConversationsApiInviteRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiInvite
    */
    readonly token?: string
    
    /**
    * The ID of the public or private channel to invite user(s) to.
    * @type {string}
    * @memberof ConversationsApiInvite
    */
    readonly channel?: string
    
    /**
    * A comma separated list of user IDs. Up to 1000 users may be listed.
    * @type {string}
    * @memberof ConversationsApiInvite
    */
    readonly users?: string
    
} & ConversationsInviteRequest

/**
 * Request parameters for join operation in ConversationsApi.
 * @export
 * @interface ConversationsApiJoinRequest
 */
export type ConversationsApiJoinRequest = {
    
    /**
    * Authentication token. Requires scope: `channels:write`
    * @type {string}
    * @memberof ConversationsApiJoin
    */
    readonly token?: string
    
    /**
    * ID of conversation to join
    * @type {string}
    * @memberof ConversationsApiJoin
    */
    readonly channel?: string
    
} & ConversationsJoinRequest

/**
 * Request parameters for kick operation in ConversationsApi.
 * @export
 * @interface ConversationsApiKickRequest
 */
export type ConversationsApiKickRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiKick
    */
    readonly token?: string
    
    /**
    * ID of conversation to remove user from.
    * @type {string}
    * @memberof ConversationsApiKick
    */
    readonly channel?: string
    
    /**
    * User ID to be removed.
    * @type {string}
    * @memberof ConversationsApiKick
    */
    readonly user?: string
    
} & ConversationsKickRequest

/**
 * Request parameters for leave operation in ConversationsApi.
 * @export
 * @interface ConversationsApiLeaveRequest
 */
export type ConversationsApiLeaveRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiLeave
    */
    readonly token?: string
    
    /**
    * Conversation to leave
    * @type {string}
    * @memberof ConversationsApiLeave
    */
    readonly channel?: string
    
} & ConversationsLeaveRequest

/**
 * Request parameters for list operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListRequest
 */
export type ConversationsApiListRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:read`
    * @type {string}
    * @memberof ConversationsApiList
    */
    readonly token?: string
    
    /**
    * Set to `true` to exclude archived channels from the list
    * @type {boolean}
    * @memberof ConversationsApiList
    */
    readonly excludeArchived?: boolean
    
    /**
    * Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
    * @type {string}
    * @memberof ConversationsApiList
    */
    readonly types?: string
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\'t been reached. Must be an integer no larger than 1000.
    * @type {number}
    * @memberof ConversationsApiList
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ConversationsApiList
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for mark operation in ConversationsApi.
 * @export
 * @interface ConversationsApiMarkRequest
 */
export type ConversationsApiMarkRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiMark
    */
    readonly token?: string
    
    /**
    * Channel or conversation to set the read cursor for.
    * @type {string}
    * @memberof ConversationsApiMark
    */
    readonly channel?: string
    
    /**
    * Unique identifier of message you want marked as most recently seen in this conversation.
    * @type {number}
    * @memberof ConversationsApiMark
    */
    readonly ts?: number
    
} & ConversationsMarkRequest

/**
 * Request parameters for members operation in ConversationsApi.
 * @export
 * @interface ConversationsApiMembersRequest
 */
export type ConversationsApiMembersRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:read`
    * @type {string}
    * @memberof ConversationsApiMembers
    */
    readonly token?: string
    
    /**
    * ID of the conversation to retrieve members for
    * @type {string}
    * @memberof ConversationsApiMembers
    */
    readonly channel?: string
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\'t been reached.
    * @type {number}
    * @memberof ConversationsApiMembers
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ConversationsApiMembers
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for open operation in ConversationsApi.
 * @export
 * @interface ConversationsApiOpenRequest
 */
export type ConversationsApiOpenRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiOpen
    */
    readonly token?: string
    
    /**
    * Resume a conversation by supplying an `im` or `mpim`\\\'s ID. Or provide the `users` field instead.
    * @type {string}
    * @memberof ConversationsApiOpen
    */
    readonly channel?: string
    
    /**
    * Boolean, indicates you want the full IM channel definition in the response.
    * @type {boolean}
    * @memberof ConversationsApiOpen
    */
    readonly returnIm?: boolean
    
    /**
    * Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`.
    * @type {string}
    * @memberof ConversationsApiOpen
    */
    readonly users?: string
    
} & ConversationsOpenRequest

/**
 * Request parameters for rename operation in ConversationsApi.
 * @export
 * @interface ConversationsApiRenameRequest
 */
export type ConversationsApiRenameRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiRename
    */
    readonly token?: string
    
    /**
    * ID of conversation to rename
    * @type {string}
    * @memberof ConversationsApiRename
    */
    readonly channel?: string
    
    /**
    * New name for conversation.
    * @type {string}
    * @memberof ConversationsApiRename
    */
    readonly name?: string
    
} & ConversationsRenameRequest

/**
 * Request parameters for replies operation in ConversationsApi.
 * @export
 * @interface ConversationsApiRepliesRequest
 */
export type ConversationsApiRepliesRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:history`
    * @type {string}
    * @memberof ConversationsApiReplies
    */
    readonly token?: string
    
    /**
    * Conversation ID to fetch thread from.
    * @type {string}
    * @memberof ConversationsApiReplies
    */
    readonly channel?: string
    
    /**
    * Unique identifier of a thread\'s parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message.
    * @type {number}
    * @memberof ConversationsApiReplies
    */
    readonly ts?: number
    
    /**
    * End of time range of messages to include in results.
    * @type {number}
    * @memberof ConversationsApiReplies
    */
    readonly latest?: number
    
    /**
    * Start of time range of messages to include in results.
    * @type {number}
    * @memberof ConversationsApiReplies
    */
    readonly oldest?: number
    
    /**
    * Include messages with latest or oldest timestamp in results only when either timestamp is specified.
    * @type {boolean}
    * @memberof ConversationsApiReplies
    */
    readonly inclusive?: boolean
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\'t been reached.
    * @type {number}
    * @memberof ConversationsApiReplies
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ConversationsApiReplies
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for setPurpose operation in ConversationsApi.
 * @export
 * @interface ConversationsApiSetPurposeRequest
 */
export type ConversationsApiSetPurposeRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiSetPurpose
    */
    readonly token?: string
    
    /**
    * Conversation to set the purpose of
    * @type {string}
    * @memberof ConversationsApiSetPurpose
    */
    readonly channel?: string
    
    /**
    * A new, specialer purpose
    * @type {string}
    * @memberof ConversationsApiSetPurpose
    */
    readonly purpose?: string
    
} & ConversationsSetPurposeRequest

/**
 * Request parameters for setTopic operation in ConversationsApi.
 * @export
 * @interface ConversationsApiSetTopicRequest
 */
export type ConversationsApiSetTopicRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiSetTopic
    */
    readonly token?: string
    
    /**
    * Conversation to set the topic of
    * @type {string}
    * @memberof ConversationsApiSetTopic
    */
    readonly channel?: string
    
    /**
    * The new topic string. Does not support formatting or linkification.
    * @type {string}
    * @memberof ConversationsApiSetTopic
    */
    readonly topic?: string
    
} & ConversationsSetTopicRequest

/**
 * Request parameters for unarchive operation in ConversationsApi.
 * @export
 * @interface ConversationsApiUnarchiveRequest
 */
export type ConversationsApiUnarchiveRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:write`
    * @type {string}
    * @memberof ConversationsApiUnarchive
    */
    readonly token?: string
    
    /**
    * ID of conversation to unarchive
    * @type {string}
    * @memberof ConversationsApiUnarchive
    */
    readonly channel?: string
    
} & ConversationsUnarchiveRequest

/**
 * ConversationsApiGenerated - object-oriented interface
 * @export
 * @class ConversationsApiGenerated
 * @extends {BaseAPI}
 */
export class ConversationsApiGenerated extends BaseAPI {
    /**
     * Archives a conversation.
     * @param {ConversationsApiArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public archive(requestParameters: ConversationsApiArchiveRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).archive(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Closes a direct message or multi-person direct message.
     * @param {ConversationsApiCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public close(requestParameters: ConversationsApiCloseRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).close(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a public or private channel-based conversation
     * @param {ConversationsApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public create(requestParameters: ConversationsApiCreateRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).create(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a conversation\'s history of messages and events.
     * @param {ConversationsApiHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public history(requestParameters: ConversationsApiHistoryRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).history(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a conversation.
     * @param {ConversationsApiInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public info(requestParameters: ConversationsApiInfoRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).info(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invites users to a channel.
     * @param {ConversationsApiInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public invite(requestParameters: ConversationsApiInviteRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).invite(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Joins an existing conversation.
     * @param {ConversationsApiJoinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public join(requestParameters: ConversationsApiJoinRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).join(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a user from a conversation.
     * @param {ConversationsApiKickRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public kick(requestParameters: ConversationsApiKickRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).kick(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Leaves a conversation.
     * @param {ConversationsApiLeaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public leave(requestParameters: ConversationsApiLeaveRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).leave(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all channels in a Slack team.
     * @param {ConversationsApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public list(requestParameters: ConversationsApiListRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the read cursor in a channel.
     * @param {ConversationsApiMarkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public mark(requestParameters: ConversationsApiMarkRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).mark(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve members of a conversation.
     * @param {ConversationsApiMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public members(requestParameters: ConversationsApiMembersRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).members(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Opens or resumes a direct message or multi-person direct message.
     * @param {ConversationsApiOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public open(requestParameters: ConversationsApiOpenRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).open(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames a conversation.
     * @param {ConversationsApiRenameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public rename(requestParameters: ConversationsApiRenameRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).rename(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a thread of messages posted to a conversation
     * @param {ConversationsApiRepliesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public replies(requestParameters: ConversationsApiRepliesRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).replies(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the purpose for a conversation.
     * @param {ConversationsApiSetPurposeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public setPurpose(requestParameters: ConversationsApiSetPurposeRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).setPurpose(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the topic for a conversation.
     * @param {ConversationsApiSetTopicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public setTopic(requestParameters: ConversationsApiSetTopicRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).setTopic(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reverses conversation archival.
     * @param {ConversationsApiUnarchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public unarchive(requestParameters: ConversationsApiUnarchiveRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).unarchive(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
