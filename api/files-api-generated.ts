/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FilesDeleteRequest } from '../models';
// @ts-ignore
import { FilesDeleteResponse } from '../models';
// @ts-ignore
import { FilesDeletedefaultResponse } from '../models';
// @ts-ignore
import { FilesInfoResponse } from '../models';
// @ts-ignore
import { FilesInfodefaultResponse } from '../models';
// @ts-ignore
import { FilesListResponse } from '../models';
// @ts-ignore
import { FilesListdefaultResponse } from '../models';
// @ts-ignore
import { FilesRevokePublicUrlRequest } from '../models';
// @ts-ignore
import { FilesRevokePublicUrlResponse } from '../models';
// @ts-ignore
import { FilesRevokePublicUrldefaultResponse } from '../models';
// @ts-ignore
import { FilesSharedPublicUrlRequest } from '../models';
// @ts-ignore
import { FilesSharedPublicUrlResponse } from '../models';
// @ts-ignore
import { FilesSharedPublicUrldefaultResponse } from '../models';
// @ts-ignore
import { FilesUploadRequest } from '../models';
// @ts-ignore
import { FilesUploadResponse } from '../models';
// @ts-ignore
import { FilesUploaddefaultResponse } from '../models';
// @ts-ignore
import { FilescommentsDeleteCommentRequest } from '../models';
// @ts-ignore
import { FilescommentsDeleteCommentResponse } from '../models';
// @ts-ignore
import { FilescommentsDeleteCommentdefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteAddFromRemoteRequest } from '../models';
// @ts-ignore
import { FilesremoteAddFromRemoteResponse } from '../models';
// @ts-ignore
import { FilesremoteAddFromRemotedefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteDeleteFileRequest } from '../models';
// @ts-ignore
import { FilesremoteDeleteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteDeleteFiledefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteGetInfoResponse } from '../models';
// @ts-ignore
import { FilesremoteGetInfodefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteListRemoteFilesResponse } from '../models';
// @ts-ignore
import { FilesremoteListRemoteFilesdefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteShareRemoteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteShareRemoteFiledefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFileRequest } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFiledefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a file from a remote service
         * @param {string} [title] Title of the file being shared.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [externalUrl] URL of the remote file.
         * @param {string} [filetype] type of file
         * @param {string} [indexableFileContents] A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
         * @param {string} [previewImage] Preview of the document via &#x60;multipart/form-data&#x60;.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteAddFromRemoteRequest} [filesremoteAddFromRemoteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFromRemote: async (title?: string, externalId?: string, externalUrl?: string, filetype?: string, indexableFileContents?: string, previewImage?: string, token?: string, filesremoteAddFromRemoteRequest?: FilesremoteAddFromRemoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (externalUrl !== undefined) {
                await addFormParam('external_url', externalUrl, false, true)
            }
    
            if (filetype !== undefined) {
                await addFormParam('filetype', filetype, false, true)
            }
    
            if (indexableFileContents !== undefined) {
                await addFormParam('indexable_file_contents', indexableFileContents, false, true)
            }
    
            if (previewImage !== undefined) {
                await addFormParam('preview_image', previewImage, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteAddFromRemoteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.add',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteAddFromRemoteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a file.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:write:user&#x60;
         * @param {string} [file] ID of file to delete.
         * @param {FilesDeleteRequest} [filesDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete: async (token?: string, file?: string, filesDeleteRequest?: FilesDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:write:user"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesDeleteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.delete',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesDeleteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing comment on a file.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:write:user&#x60;
         * @param {string} [file] File to delete a comment from.
         * @param {string} [id] The comment to delete.
         * @param {FilescommentsDeleteCommentRequest} [filescommentsDeleteCommentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment: async (token?: string, file?: string, id?: string, filescommentsDeleteCommentRequest?: FilescommentsDeleteCommentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.comments.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:write:user"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (id !== undefined) {
                await addFormParam('id', id, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filescommentsDeleteCommentRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.comments.delete',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filescommentsDeleteCommentRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a remote file.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteDeleteFileRequest} [filesremoteDeleteFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (externalId?: string, file?: string, token?: string, filesremoteDeleteFileRequest?: FilesremoteDeleteFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteDeleteFileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.remove',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteDeleteFileRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:read&#x60;
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (token?: string, file?: string, externalId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about a file.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:read&#x60;
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [count] 
         * @param {string} [page] 
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\&#39;t been reached.
         * @param {string} [cursor] Parameter for pagination. File comments are paginated for a single file. Set &#x60;cursor&#x60; equal to the &#x60;next_cursor&#x60; attribute returned by the previous request\&#39;s &#x60;response_metadata&#x60;. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \&quot;page\&quot; of the collection of comments. See [pagination](https://slack.dev) for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (token?: string, file?: string, count?: string, page?: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List for a team, in a channel, or from a user with applied filters.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:read&#x60;
         * @param {string} [user] Filter files created by a single user.
         * @param {string} [channel] Filter files appearing in a specific channel, indicated by its ID.
         * @param {number} [tsFrom] Filter files created after this timestamp (inclusive).
         * @param {number} [tsTo] Filter files created before this timestamp (inclusive).
         * @param {string} [types] Filter files by type ([see below](https://slack.dev)). You can pass multiple values in the types argument, like &#x60;types&#x3D;spaces,snippets&#x60;.The default value is &#x60;all&#x60;, which does not filter the list.
         * @param {string} [count] 
         * @param {string} [page] 
         * @param {boolean} [showFilesHiddenByLimit] Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (token?: string, user?: string, channel?: string, tsFrom?: number, tsTo?: number, types?: string, count?: string, page?: string, showFilesHiddenByLimit?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (tsFrom !== undefined) {
                localVarQueryParameter['ts_from'] = tsFrom;
            }

            if (tsTo !== undefined) {
                localVarQueryParameter['ts_to'] = tsTo;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (showFilesHiddenByLimit !== undefined) {
                localVarQueryParameter['show_files_hidden_by_limit'] = showFilesHiddenByLimit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:read&#x60;
         * @param {string} [channel] Filter files appearing in a specific channel, indicated by its ID.
         * @param {number} [tsFrom] Filter files created after this timestamp (inclusive).
         * @param {number} [tsTo] Filter files created before this timestamp (inclusive).
         * @param {number} [limit] The maximum number of items to return.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoteFiles: async (token?: string, channel?: string, tsFrom?: number, tsTo?: number, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (tsFrom !== undefined) {
                localVarQueryParameter['ts_from'] = tsFrom;
            }

            if (tsTo !== undefined) {
                localVarQueryParameter['ts_to'] = tsTo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes public/external sharing access for a file
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:write:user&#x60;
         * @param {string} [file] File to revoke
         * @param {FilesRevokePublicUrlRequest} [filesRevokePublicUrlRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePublicURL: async (token?: string, file?: string, filesRevokePublicUrlRequest?: FilesRevokePublicUrlRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.revokePublicURL`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:write:user"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesRevokePublicUrlRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.revokePublicURL',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesRevokePublicUrlRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a remote file into a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:share&#x60;
         * @param {string} [file] Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required.
         * @param {string} [externalId] The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required.
         * @param {string} [channels] Comma-separated list of channel IDs where the file will be shared.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRemoteFile: async (token?: string, file?: string, externalId?: string, channels?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:share"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.share',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables a file for public/external sharing.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:write:user&#x60;
         * @param {string} [file] File to share
         * @param {FilesSharedPublicUrlRequest} [filesSharedPublicUrlRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedPublicURL: async (token?: string, file?: string, filesSharedPublicUrlRequest?: FilesSharedPublicUrlRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.sharedPublicURL`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:write:user"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesSharedPublicUrlRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.sharedPublicURL',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesSharedPublicUrlRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing remote file.
         * @param {string} [title] Title of the file being shared.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [externalUrl] URL of the remote file.
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [filetype] type of file
         * @param {string} [indexableFileContents] File containing contents that can be used to improve searchability for the remote file.
         * @param {string} [previewImage] Preview of the document via &#x60;multipart/form-data&#x60;.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteUpdateRemoteFileRequest} [filesremoteUpdateRemoteFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteFile: async (title?: string, externalId?: string, externalUrl?: string, file?: string, filetype?: string, indexableFileContents?: string, previewImage?: string, token?: string, filesremoteUpdateRemoteFileRequest?: FilesremoteUpdateRemoteFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (externalUrl !== undefined) {
                await addFormParam('external_url', externalUrl, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (filetype !== undefined) {
                await addFormParam('filetype', filetype, false, true)
            }
    
            if (indexableFileContents !== undefined) {
                await addFormParam('indexable_file_contents', indexableFileContents, false, true)
            }
    
            if (previewImage !== undefined) {
                await addFormParam('preview_image', previewImage, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteUpdateRemoteFileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.update',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteUpdateRemoteFileRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads or creates a file.
         * @param {string} [title] Title of file.
         * @param {string} [channels] Comma-separated list of channel names or IDs where the file will be shared.
         * @param {string} [content] File contents via a POST variable. If omitting this parameter, you must provide a &#x60;file&#x60;.
         * @param {string} [file] File contents via &#x60;multipart/form-data&#x60;. If omitting this parameter, you must submit &#x60;content&#x60;.
         * @param {string} [filename] Filename of file.
         * @param {string} [filetype] A [file type](https://slack.dev) identifier.
         * @param {string} [initialComment] The message text introducing the file in specified &#x60;channels&#x60;.
         * @param {number} [threadTs] Provide another message\\\&#39;s &#x60;ts&#x60; value to upload this file as a reply. Never use a reply\\\&#39;s &#x60;ts&#x60; value; use its parent instead.
         * @param {string} [token] Authentication token. Requires scope: &#x60;files:write:user&#x60;
         * @param {FilesUploadRequest} [filesUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (title?: string, channels?: string, content?: string, file?: string, filename?: string, filetype?: string, initialComment?: string, threadTs?: number, token?: string, filesUploadRequest?: FilesUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["files:write:user"], configuration)

            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (channels !== undefined) {
                await addFormParam('channels', channels, false, true)
            }
    
            if (content !== undefined) {
                await addFormParam('content', content, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (filename !== undefined) {
                await addFormParam('filename', filename, false, true)
            }
    
            if (filetype !== undefined) {
                await addFormParam('filetype', filetype, false, true)
            }
    
            if (initialComment !== undefined) {
                await addFormParam('initial_comment', initialComment, false, true)
            }
    
            if (threadTs !== undefined) {
                await addFormParam('thread_ts', threadTs, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.upload',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a file from a remote service
         * @param {FilesApiAddFromRemoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFromRemote(requestParameters: FilesApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteAddFromRemoteResponse>> {
            const filesremoteAddFromRemoteRequest: FilesremoteAddFromRemoteRequest = {
                title: requestParameters.title,
                external_id: requestParameters.external_id,
                external_url: requestParameters.external_url,
                filetype: requestParameters.filetype,
                indexable_file_contents: requestParameters.indexable_file_contents,
                preview_image: requestParameters.preview_image,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFromRemote(requestParameters.title, requestParameters.externalId, requestParameters.externalUrl, requestParameters.filetype, requestParameters.indexableFileContents, requestParameters.previewImage, requestParameters.token, filesremoteAddFromRemoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a file.
         * @param {FilesApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete(requestParameters: FilesApiDeleteRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesDeleteResponse>> {
            const filesDeleteRequest: FilesDeleteRequest = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete(requestParameters.token, requestParameters.file, filesDeleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an existing comment on a file.
         * @param {FilesApiDeleteCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComment(requestParameters: FilesApiDeleteCommentRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilescommentsDeleteCommentResponse>> {
            const filescommentsDeleteCommentRequest: FilescommentsDeleteCommentRequest = {
                file: requestParameters.file,
                id: requestParameters.id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComment(requestParameters.token, requestParameters.file, requestParameters.id, filescommentsDeleteCommentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a remote file.
         * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(requestParameters: FilesApiDeleteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteDeleteFileResponse>> {
            const filesremoteDeleteFileRequest: FilesremoteDeleteFileRequest = {
                external_id: requestParameters.external_id,
                file: requestParameters.file,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(requestParameters.externalId, requestParameters.file, requestParameters.token, filesremoteDeleteFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(requestParameters: FilesApiGetInfoRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteGetInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(requestParameters.token, requestParameters.file, requestParameters.externalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets information about a file.
         * @param {FilesApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(requestParameters: FilesApiInfoRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(requestParameters.token, requestParameters.file, requestParameters.count, requestParameters.page, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List for a team, in a channel, or from a user with applied filters.
         * @param {FilesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: FilesApiListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.token, requestParameters.user, requestParameters.channel, requestParameters.tsFrom, requestParameters.tsTo, requestParameters.types, requestParameters.count, requestParameters.page, requestParameters.showFilesHiddenByLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesApiListRemoteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRemoteFiles(requestParameters: FilesApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteListRemoteFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRemoteFiles(requestParameters.token, requestParameters.channel, requestParameters.tsFrom, requestParameters.tsTo, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revokes public/external sharing access for a file
         * @param {FilesApiRevokePublicURLRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePublicURL(requestParameters: FilesApiRevokePublicURLRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesRevokePublicUrlResponse>> {
            const filesRevokePublicUrlRequest: FilesRevokePublicUrlRequest = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePublicURL(requestParameters.token, requestParameters.file, filesRevokePublicUrlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share a remote file into a channel.
         * @param {FilesApiShareRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareRemoteFile(requestParameters: FilesApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteShareRemoteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareRemoteFile(requestParameters.token, requestParameters.file, requestParameters.externalId, requestParameters.channels, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enables a file for public/external sharing.
         * @param {FilesApiSharedPublicURLRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sharedPublicURL(requestParameters: FilesApiSharedPublicURLRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesSharedPublicUrlResponse>> {
            const filesSharedPublicUrlRequest: FilesSharedPublicUrlRequest = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.sharedPublicURL(requestParameters.token, requestParameters.file, filesSharedPublicUrlRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing remote file.
         * @param {FilesApiUpdateRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRemoteFile(requestParameters: FilesApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteUpdateRemoteFileResponse>> {
            const filesremoteUpdateRemoteFileRequest: FilesremoteUpdateRemoteFileRequest = {
                title: requestParameters.title,
                external_id: requestParameters.external_id,
                external_url: requestParameters.external_url,
                file: requestParameters.file,
                filetype: requestParameters.filetype,
                indexable_file_contents: requestParameters.indexable_file_contents,
                preview_image: requestParameters.preview_image,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRemoteFile(requestParameters.title, requestParameters.externalId, requestParameters.externalUrl, requestParameters.file, requestParameters.filetype, requestParameters.indexableFileContents, requestParameters.previewImage, requestParameters.token, filesremoteUpdateRemoteFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads or creates a file.
         * @param {FilesApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(requestParameters: FilesApiUploadRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesUploadResponse>> {
            const filesUploadRequest: FilesUploadRequest = {
                title: requestParameters.title,
                channels: requestParameters.channels,
                content: requestParameters.content,
                file: requestParameters.file,
                filename: requestParameters.filename,
                filetype: requestParameters.filetype,
                initial_comment: requestParameters.initial_comment,
                thread_ts: requestParameters.thread_ts,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(requestParameters.title, requestParameters.channels, requestParameters.content, requestParameters.file, requestParameters.filename, requestParameters.filetype, requestParameters.initialComment, requestParameters.threadTs, requestParameters.token, filesUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Adds a file from a remote service
         * @param {FilesApiAddFromRemoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFromRemote(requestParameters: FilesApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteAddFromRemoteResponse> {
            return localVarFp.addFromRemote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a file.
         * @param {FilesApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete(requestParameters: FilesApiDeleteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesDeleteResponse> {
            return localVarFp.delete(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing comment on a file.
         * @param {FilesApiDeleteCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComment(requestParameters: FilesApiDeleteCommentRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilescommentsDeleteCommentResponse> {
            return localVarFp.deleteComment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a remote file.
         * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(requestParameters: FilesApiDeleteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteDeleteFileResponse> {
            return localVarFp.deleteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(requestParameters: FilesApiGetInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteGetInfoResponse> {
            return localVarFp.getInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about a file.
         * @param {FilesApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(requestParameters: FilesApiInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesInfoResponse> {
            return localVarFp.info(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List for a team, in a channel, or from a user with applied filters.
         * @param {FilesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: FilesApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesApiListRemoteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoteFiles(requestParameters: FilesApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteListRemoteFilesResponse> {
            return localVarFp.listRemoteFiles(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes public/external sharing access for a file
         * @param {FilesApiRevokePublicURLRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePublicURL(requestParameters: FilesApiRevokePublicURLRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesRevokePublicUrlResponse> {
            return localVarFp.revokePublicURL(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a remote file into a channel.
         * @param {FilesApiShareRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRemoteFile(requestParameters: FilesApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteShareRemoteFileResponse> {
            return localVarFp.shareRemoteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables a file for public/external sharing.
         * @param {FilesApiSharedPublicURLRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedPublicURL(requestParameters: FilesApiSharedPublicURLRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesSharedPublicUrlResponse> {
            return localVarFp.sharedPublicURL(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing remote file.
         * @param {FilesApiUpdateRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteFile(requestParameters: FilesApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteUpdateRemoteFileResponse> {
            return localVarFp.updateRemoteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads or creates a file.
         * @param {FilesApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(requestParameters: FilesApiUploadRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesUploadResponse> {
            return localVarFp.upload(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFromRemote operation in FilesApi.
 * @export
 * @interface FilesApiAddFromRemoteRequest
 */
export type FilesApiAddFromRemoteRequest = {
    
    /**
    * Title of the file being shared.
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly title?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly externalId?: string
    
    /**
    * URL of the remote file.
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly externalUrl?: string
    
    /**
    * type of file
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly filetype?: string
    
    /**
    * A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly indexableFileContents?: string
    
    /**
    * Preview of the document via `multipart/form-data`.
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly previewImage?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesApiAddFromRemote
    */
    readonly token?: string
    
} & FilesremoteAddFromRemoteRequest

/**
 * Request parameters for delete operation in FilesApi.
 * @export
 * @interface FilesApiDeleteRequest
 */
export type FilesApiDeleteRequest = {
    
    /**
    * Authentication token. Requires scope: `files:write:user`
    * @type {string}
    * @memberof FilesApiDelete
    */
    readonly token?: string
    
    /**
    * ID of file to delete.
    * @type {string}
    * @memberof FilesApiDelete
    */
    readonly file?: string
    
} & FilesDeleteRequest

/**
 * Request parameters for deleteComment operation in FilesApi.
 * @export
 * @interface FilesApiDeleteCommentRequest
 */
export type FilesApiDeleteCommentRequest = {
    
    /**
    * Authentication token. Requires scope: `files:write:user`
    * @type {string}
    * @memberof FilesApiDeleteComment
    */
    readonly token?: string
    
    /**
    * File to delete a comment from.
    * @type {string}
    * @memberof FilesApiDeleteComment
    */
    readonly file?: string
    
    /**
    * The comment to delete.
    * @type {string}
    * @memberof FilesApiDeleteComment
    */
    readonly id?: string
    
} & FilescommentsDeleteCommentRequest

/**
 * Request parameters for deleteFile operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileRequest
 */
export type FilesApiDeleteFileRequest = {
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesApiDeleteFile
    */
    readonly externalId?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesApiDeleteFile
    */
    readonly file?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesApiDeleteFile
    */
    readonly token?: string
    
} & FilesremoteDeleteFileRequest

/**
 * Request parameters for getInfo operation in FilesApi.
 * @export
 * @interface FilesApiGetInfoRequest
 */
export type FilesApiGetInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:read`
    * @type {string}
    * @memberof FilesApiGetInfo
    */
    readonly token?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesApiGetInfo
    */
    readonly file?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesApiGetInfo
    */
    readonly externalId?: string
    
}

/**
 * Request parameters for info operation in FilesApi.
 * @export
 * @interface FilesApiInfoRequest
 */
export type FilesApiInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `files:read`
    * @type {string}
    * @memberof FilesApiInfo
    */
    readonly token?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesApiInfo
    */
    readonly file?: string
    
    /**
    * 
    * @type {string}
    * @memberof FilesApiInfo
    */
    readonly count?: string
    
    /**
    * 
    * @type {string}
    * @memberof FilesApiInfo
    */
    readonly page?: string
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\'t been reached.
    * @type {number}
    * @memberof FilesApiInfo
    */
    readonly limit?: number
    
    /**
    * Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request\'s `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first \"page\" of the collection of comments. See [pagination](https://slack.dev) for more details.
    * @type {string}
    * @memberof FilesApiInfo
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for list operation in FilesApi.
 * @export
 * @interface FilesApiListRequest
 */
export type FilesApiListRequest = {
    
    /**
    * Authentication token. Requires scope: `files:read`
    * @type {string}
    * @memberof FilesApiList
    */
    readonly token?: string
    
    /**
    * Filter files created by a single user.
    * @type {string}
    * @memberof FilesApiList
    */
    readonly user?: string
    
    /**
    * Filter files appearing in a specific channel, indicated by its ID.
    * @type {string}
    * @memberof FilesApiList
    */
    readonly channel?: string
    
    /**
    * Filter files created after this timestamp (inclusive).
    * @type {number}
    * @memberof FilesApiList
    */
    readonly tsFrom?: number
    
    /**
    * Filter files created before this timestamp (inclusive).
    * @type {number}
    * @memberof FilesApiList
    */
    readonly tsTo?: number
    
    /**
    * Filter files by type ([see below](https://slack.dev)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list.
    * @type {string}
    * @memberof FilesApiList
    */
    readonly types?: string
    
    /**
    * 
    * @type {string}
    * @memberof FilesApiList
    */
    readonly count?: string
    
    /**
    * 
    * @type {string}
    * @memberof FilesApiList
    */
    readonly page?: string
    
    /**
    * Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit.
    * @type {boolean}
    * @memberof FilesApiList
    */
    readonly showFilesHiddenByLimit?: boolean
    
}

/**
 * Request parameters for listRemoteFiles operation in FilesApi.
 * @export
 * @interface FilesApiListRemoteFilesRequest
 */
export type FilesApiListRemoteFilesRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:read`
    * @type {string}
    * @memberof FilesApiListRemoteFiles
    */
    readonly token?: string
    
    /**
    * Filter files appearing in a specific channel, indicated by its ID.
    * @type {string}
    * @memberof FilesApiListRemoteFiles
    */
    readonly channel?: string
    
    /**
    * Filter files created after this timestamp (inclusive).
    * @type {number}
    * @memberof FilesApiListRemoteFiles
    */
    readonly tsFrom?: number
    
    /**
    * Filter files created before this timestamp (inclusive).
    * @type {number}
    * @memberof FilesApiListRemoteFiles
    */
    readonly tsTo?: number
    
    /**
    * The maximum number of items to return.
    * @type {number}
    * @memberof FilesApiListRemoteFiles
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof FilesApiListRemoteFiles
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for revokePublicURL operation in FilesApi.
 * @export
 * @interface FilesApiRevokePublicURLRequest
 */
export type FilesApiRevokePublicURLRequest = {
    
    /**
    * Authentication token. Requires scope: `files:write:user`
    * @type {string}
    * @memberof FilesApiRevokePublicURL
    */
    readonly token?: string
    
    /**
    * File to revoke
    * @type {string}
    * @memberof FilesApiRevokePublicURL
    */
    readonly file?: string
    
} & FilesRevokePublicUrlRequest

/**
 * Request parameters for shareRemoteFile operation in FilesApi.
 * @export
 * @interface FilesApiShareRemoteFileRequest
 */
export type FilesApiShareRemoteFileRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:share`
    * @type {string}
    * @memberof FilesApiShareRemoteFile
    */
    readonly token?: string
    
    /**
    * Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
    * @type {string}
    * @memberof FilesApiShareRemoteFile
    */
    readonly file?: string
    
    /**
    * The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
    * @type {string}
    * @memberof FilesApiShareRemoteFile
    */
    readonly externalId?: string
    
    /**
    * Comma-separated list of channel IDs where the file will be shared.
    * @type {string}
    * @memberof FilesApiShareRemoteFile
    */
    readonly channels?: string
    
}

/**
 * Request parameters for sharedPublicURL operation in FilesApi.
 * @export
 * @interface FilesApiSharedPublicURLRequest
 */
export type FilesApiSharedPublicURLRequest = {
    
    /**
    * Authentication token. Requires scope: `files:write:user`
    * @type {string}
    * @memberof FilesApiSharedPublicURL
    */
    readonly token?: string
    
    /**
    * File to share
    * @type {string}
    * @memberof FilesApiSharedPublicURL
    */
    readonly file?: string
    
} & FilesSharedPublicUrlRequest

/**
 * Request parameters for updateRemoteFile operation in FilesApi.
 * @export
 * @interface FilesApiUpdateRemoteFileRequest
 */
export type FilesApiUpdateRemoteFileRequest = {
    
    /**
    * Title of the file being shared.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly title?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly externalId?: string
    
    /**
    * URL of the remote file.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly externalUrl?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly file?: string
    
    /**
    * type of file
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly filetype?: string
    
    /**
    * File containing contents that can be used to improve searchability for the remote file.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly indexableFileContents?: string
    
    /**
    * Preview of the document via `multipart/form-data`.
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly previewImage?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesApiUpdateRemoteFile
    */
    readonly token?: string
    
} & FilesremoteUpdateRemoteFileRequest

/**
 * Request parameters for upload operation in FilesApi.
 * @export
 * @interface FilesApiUploadRequest
 */
export type FilesApiUploadRequest = {
    
    /**
    * Title of file.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly title?: string
    
    /**
    * Comma-separated list of channel names or IDs where the file will be shared.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly channels?: string
    
    /**
    * File contents via a POST variable. If omitting this parameter, you must provide a `file`.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly content?: string
    
    /**
    * File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly file?: string
    
    /**
    * Filename of file.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly filename?: string
    
    /**
    * A [file type](https://slack.dev) identifier.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly filetype?: string
    
    /**
    * The message text introducing the file in specified `channels`.
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly initialComment?: string
    
    /**
    * Provide another message\\\'s `ts` value to upload this file as a reply. Never use a reply\\\'s `ts` value; use its parent instead.
    * @type {number}
    * @memberof FilesApiUpload
    */
    readonly threadTs?: number
    
    /**
    * Authentication token. Requires scope: `files:write:user`
    * @type {string}
    * @memberof FilesApiUpload
    */
    readonly token?: string
    
} & FilesUploadRequest

/**
 * FilesApiGenerated - object-oriented interface
 * @export
 * @class FilesApiGenerated
 * @extends {BaseAPI}
 */
export class FilesApiGenerated extends BaseAPI {
    /**
     * Adds a file from a remote service
     * @param {FilesApiAddFromRemoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public addFromRemote(requestParameters: FilesApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).addFromRemote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a file.
     * @param {FilesApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public delete(requestParameters: FilesApiDeleteRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).delete(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing comment on a file.
     * @param {FilesApiDeleteCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public deleteComment(requestParameters: FilesApiDeleteCommentRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteComment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a remote file.
     * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public deleteFile(requestParameters: FilesApiDeleteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a remote file added to Slack
     * @param {FilesApiGetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public getInfo(requestParameters: FilesApiGetInfoRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about a file.
     * @param {FilesApiInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public info(requestParameters: FilesApiInfoRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).info(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List for a team, in a channel, or from a user with applied filters.
     * @param {FilesApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public list(requestParameters: FilesApiListRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a remote file added to Slack
     * @param {FilesApiListRemoteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public listRemoteFiles(requestParameters: FilesApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).listRemoteFiles(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes public/external sharing access for a file
     * @param {FilesApiRevokePublicURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public revokePublicURL(requestParameters: FilesApiRevokePublicURLRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).revokePublicURL(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share a remote file into a channel.
     * @param {FilesApiShareRemoteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public shareRemoteFile(requestParameters: FilesApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).shareRemoteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables a file for public/external sharing.
     * @param {FilesApiSharedPublicURLRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public sharedPublicURL(requestParameters: FilesApiSharedPublicURLRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).sharedPublicURL(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing remote file.
     * @param {FilesApiUpdateRemoteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public updateRemoteFile(requestParameters: FilesApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).updateRemoteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads or creates a file.
     * @param {FilesApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApiGenerated
     */
    public upload(requestParameters: FilesApiUploadRequest = {}, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).upload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
