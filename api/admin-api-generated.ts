/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AdminappsApproveAppInstallationRequest } from '../models';
// @ts-ignore
import { AdminappsApproveAppInstallationResponse } from '../models';
// @ts-ignore
import { AdminappsApproveAppInstallationdefaultResponse } from '../models';
// @ts-ignore
import { AdminappsRestrictAppRequest } from '../models';
// @ts-ignore
import { AdminappsRestrictAppResponse } from '../models';
// @ts-ignore
import { AdminappsRestrictAppdefaultResponse } from '../models';
// @ts-ignore
import { AdminappsapprovedListResponse } from '../models';
// @ts-ignore
import { AdminappsapprovedListdefaultResponse } from '../models';
// @ts-ignore
import { AdminappsrequestsListResponse } from '../models';
// @ts-ignore
import { AdminappsrequestsListdefaultResponse } from '../models';
// @ts-ignore
import { AdminappsrestrictedGetListResponse } from '../models';
// @ts-ignore
import { AdminappsrestrictedGetListdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsArchiveChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsArchiveChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsArchiveChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationRequest } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationResponse } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetConversationPrefsResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetConversationPrefsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetTeamsListResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetTeamsListdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsRenameChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsRenameChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsRenameChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSearchChannelsResponse } from '../models';
// @ts-ignore
import { AdminconversationsSearchChannelsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsRequest } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectionRequest } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectionResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectiondefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsekmListOriginalConnectedChannelInfoResponse } from '../models';
// @ts-ignore
import { AdminconversationsekmListOriginalConnectedChannelInfodefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessAddGroupIdpGroupsRequest } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessAddGroupIdpGroupsResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessAddGroupIdpGroupsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessListGroupsResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessListGroupsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessRemoveIdpGroupRequest } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessRemoveIdpGroupResponse } from '../models';
// @ts-ignore
import { AdminconversationsrestrictAccessRemoveIdpGroupdefaultResponse } from '../models';
// @ts-ignore
import { AdminemojiAddEmojiRequest } from '../models';
// @ts-ignore
import { AdminemojiAddEmojiResponse } from '../models';
// @ts-ignore
import { AdminemojiAddEmojidefaultResponse } from '../models';
// @ts-ignore
import { AdminemojiAliasAddRequest } from '../models';
// @ts-ignore
import { AdminemojiAliasAddResponse } from '../models';
// @ts-ignore
import { AdminemojiAliasAdddefaultResponse } from '../models';
// @ts-ignore
import { AdminemojiListEnterpriseEmojiResponse } from '../models';
// @ts-ignore
import { AdminemojiListEnterpriseEmojidefaultResponse } from '../models';
// @ts-ignore
import { AdminemojiRemoveEnterpriseEmojiRequest } from '../models';
// @ts-ignore
import { AdminemojiRemoveEnterpriseEmojiResponse } from '../models';
// @ts-ignore
import { AdminemojiRemoveEnterpriseEmojidefaultResponse } from '../models';
// @ts-ignore
import { AdminemojiRenameEmojiRequest } from '../models';
// @ts-ignore
import { AdminemojiRenameEmojiResponse } from '../models';
// @ts-ignore
import { AdminemojiRenameEmojidefaultResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsApproveRequestRequest } from '../models';
// @ts-ignore
import { AdmininviteRequestsApproveRequestResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsApproveRequestdefaultResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsDenyRequestResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsDenyRequestdefaultResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsListPendingWorkspaceInviteRequestsResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsListPendingWorkspaceInviteRequestsdefaultResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsapprovedListResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsapprovedListdefaultResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsdeniedListResponse } from '../models';
// @ts-ignore
import { AdmininviteRequestsdeniedListdefaultResponse } from '../models';
// @ts-ignore
import { AdminteamsCreateEnterpriseTeamRequest } from '../models';
// @ts-ignore
import { AdminteamsCreateEnterpriseTeamResponse } from '../models';
// @ts-ignore
import { AdminteamsCreateEnterpriseTeamdefaultResponse } from '../models';
// @ts-ignore
import { AdminteamsListAllResponse } from '../models';
// @ts-ignore
import { AdminteamsListAlldefaultResponse } from '../models';
// @ts-ignore
import { AdminteamsadminsGetAllResponse } from '../models';
// @ts-ignore
import { AdminteamsadminsGetAlldefaultResponse } from '../models';
// @ts-ignore
import { AdminteamsownersListOwnersResponse } from '../models';
// @ts-ignore
import { AdminteamsownersListOwnersdefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsGetInfoResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsGetInfodefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDefaultChannelsRequest } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDefaultChannelsResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDefaultChannelsdefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDescriptionRequest } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDescriptionResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDescriptiondefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDiscoverabilityOfWorkspaceRequest } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDiscoverabilityOfWorkspaceResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetDiscoverabilityOfWorkspacedefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetIconRequest } from '../models';
// @ts-ignore
import { AdminteamssettingsSetIconResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetIcondefaultResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetNameRequest } from '../models';
// @ts-ignore
import { AdminteamssettingsSetNameResponse } from '../models';
// @ts-ignore
import { AdminteamssettingsSetNamedefaultResponse } from '../models';
// @ts-ignore
import { AdminusergroupsAddDefaultChannelsRequest } from '../models';
// @ts-ignore
import { AdminusergroupsAddDefaultChannelsResponse } from '../models';
// @ts-ignore
import { AdminusergroupsAddDefaultChannelsdefaultResponse } from '../models';
// @ts-ignore
import { AdminusergroupsAssociateDefaultWorkspacesRequest } from '../models';
// @ts-ignore
import { AdminusergroupsAssociateDefaultWorkspacesResponse } from '../models';
// @ts-ignore
import { AdminusergroupsAssociateDefaultWorkspacesdefaultResponse } from '../models';
// @ts-ignore
import { AdminusergroupsListChannelsGetResponse } from '../models';
// @ts-ignore
import { AdminusergroupsListChannelsGetdefaultResponse } from '../models';
// @ts-ignore
import { AdminusergroupsRemoveChannelsRequest } from '../models';
// @ts-ignore
import { AdminusergroupsRemoveChannelsResponse } from '../models';
// @ts-ignore
import { AdminusergroupsRemoveChannelsdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersAddWorkspaceUserRequest } from '../models';
// @ts-ignore
import { AdminusersAddWorkspaceUserResponse } from '../models';
// @ts-ignore
import { AdminusersAddWorkspaceUserdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersInviteUserToWorkspaceRequest } from '../models';
// @ts-ignore
import { AdminusersInviteUserToWorkspaceResponse } from '../models';
// @ts-ignore
import { AdminusersInviteUserToWorkspacedefaultResponse } from '../models';
// @ts-ignore
import { AdminusersListWorkspaceUsersResponse } from '../models';
// @ts-ignore
import { AdminusersListWorkspaceUsersdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersRemoveUserFromWorkspaceRequest } from '../models';
// @ts-ignore
import { AdminusersRemoveUserFromWorkspaceResponse } from '../models';
// @ts-ignore
import { AdminusersRemoveUserFromWorkspacedefaultResponse } from '../models';
// @ts-ignore
import { AdminusersSetAdminUserRequest } from '../models';
// @ts-ignore
import { AdminusersSetAdminUserResponse } from '../models';
// @ts-ignore
import { AdminusersSetAdminUserdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersSetExpirationGuestRequest } from '../models';
// @ts-ignore
import { AdminusersSetExpirationGuestResponse } from '../models';
// @ts-ignore
import { AdminusersSetExpirationGuestdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersSetRegularUserRequest } from '../models';
// @ts-ignore
import { AdminusersSetRegularUserResponse } from '../models';
// @ts-ignore
import { AdminusersSetRegularUserdefaultResponse } from '../models';
// @ts-ignore
import { AdminusersSetWorkspaceOwnerRequest } from '../models';
// @ts-ignore
import { AdminusersSetWorkspaceOwnerResponse } from '../models';
// @ts-ignore
import { AdminusersSetWorkspaceOwnerdefaultResponse } from '../models';
// @ts-ignore
import { AdminuserssessionInvalidateSessionRequest } from '../models';
// @ts-ignore
import { AdminuserssessionInvalidateSessionResponse } from '../models';
// @ts-ignore
import { AdminuserssessionInvalidateSessiondefaultResponse } from '../models';
// @ts-ignore
import { AdminuserssessionResetSessionsRequest } from '../models';
// @ts-ignore
import { AdminuserssessionResetSessionsResponse } from '../models';
// @ts-ignore
import { AdminuserssessionResetSessionsdefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add one or more default channels to an IDP group.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
         * @param {string} channelIds Comma separated string of channel IDs.
         * @param {string} usergroupId ID of the IDP group to add default channels for.
         * @param {AdminusergroupsAddDefaultChannelsRequest} adminusergroupsAddDefaultChannelsRequest 
         * @param {string} [teamId] The workspace to add default channels in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDefaultChannels: async (token: string, channelIds: string, usergroupId: string, adminusergroupsAddDefaultChannelsRequest: AdminusergroupsAddDefaultChannelsRequest, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('addDefaultChannels', 'token', token)
            // verify required parameter 'channelIds' is not null or undefined
            assertParamExists('addDefaultChannels', 'channelIds', channelIds)
            // verify required parameter 'usergroupId' is not null or undefined
            assertParamExists('addDefaultChannels', 'usergroupId', usergroupId)
            // verify required parameter 'adminusergroupsAddDefaultChannelsRequest' is not null or undefined
            assertParamExists('addDefaultChannels', 'adminusergroupsAddDefaultChannelsRequest', adminusergroupsAddDefaultChannelsRequest)
            const localVarPath = `/admin.usergroups.addChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.usergroups:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelIds !== undefined) {
                await addFormParam('channel_ids', channelIds, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (usergroupId !== undefined) {
                await addFormParam('usergroup_id', usergroupId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusergroupsAddDefaultChannelsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.usergroups.addChannels',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusergroupsAddDefaultChannelsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an emoji.
         * @param {string} name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} url The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best.
         * @param {AdminemojiAddEmojiRequest} adminemojiAddEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmoji: async (name: string, token: string, url: string, adminemojiAddEmojiRequest: AdminemojiAddEmojiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addEmoji', 'name', name)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('addEmoji', 'token', token)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('addEmoji', 'url', url)
            // verify required parameter 'adminemojiAddEmojiRequest' is not null or undefined
            assertParamExists('addEmoji', 'adminemojiAddEmojiRequest', adminemojiAddEmojiRequest)
            const localVarPath = `/admin.emoji.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
            if (url !== undefined) {
                await addFormParam('url', url, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminemojiAddEmojiRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.emoji.add',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminemojiAddEmojiRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an allowlist of IDP groups for accessing a channel
         * @param {string} channelId The channel to link this group to.
         * @param {string} groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {AdminconversationsrestrictAccessAddGroupIdpGroupsRequest} adminconversationsrestrictAccessAddGroupIdpGroupsRequest 
         * @param {string} [teamId] The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupIdpGroups: async (channelId: string, groupId: string, token: string, adminconversationsrestrictAccessAddGroupIdpGroupsRequest: AdminconversationsrestrictAccessAddGroupIdpGroupsRequest, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('addGroupIdpGroups', 'channelId', channelId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addGroupIdpGroups', 'groupId', groupId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('addGroupIdpGroups', 'token', token)
            // verify required parameter 'adminconversationsrestrictAccessAddGroupIdpGroupsRequest' is not null or undefined
            assertParamExists('addGroupIdpGroups', 'adminconversationsrestrictAccessAddGroupIdpGroupsRequest', adminconversationsrestrictAccessAddGroupIdpGroupsRequest)
            const localVarPath = `/admin.conversations.restrictAccess.addGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)

            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (groupId !== undefined) {
                await addFormParam('group_id', groupId, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsrestrictAccessAddGroupIdpGroupsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.restrictAccess.addGroup',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsrestrictAccessAddGroupIdpGroupsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an Enterprise user to a workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId The ID of the user to add to the workspace.
         * @param {AdminusersAddWorkspaceUserRequest} adminusersAddWorkspaceUserRequest 
         * @param {string} [channelIds] Comma separated values of channel IDs to add user in the new workspace.
         * @param {boolean} [isRestricted] True if user should be added to the workspace as a guest.
         * @param {boolean} [isUltraRestricted] True if user should be added to the workspace as a single-channel guest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser: async (token: string, teamId: string, userId: string, adminusersAddWorkspaceUserRequest: AdminusersAddWorkspaceUserRequest, channelIds?: string, isRestricted?: boolean, isUltraRestricted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('addWorkspaceUser', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addWorkspaceUser', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addWorkspaceUser', 'userId', userId)
            // verify required parameter 'adminusersAddWorkspaceUserRequest' is not null or undefined
            assertParamExists('addWorkspaceUser', 'adminusersAddWorkspaceUserRequest', adminusersAddWorkspaceUserRequest)
            const localVarPath = `/admin.users.assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelIds !== undefined) {
                await addFormParam('channel_ids', channelIds, false, true)
            }
    
            if (isRestricted !== undefined) {
                await addFormParam('is_restricted', isRestricted, false, true)
            }
    
            if (isUltraRestricted !== undefined) {
                await addFormParam('is_ultra_restricted', isUltraRestricted, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersAddWorkspaceUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.assign',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersAddWorkspaceUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an emoji alias.
         * @param {string} aliasFor The alias of the emoji.
         * @param {string} name The name of the emoji to be aliased. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {AdminemojiAliasAddRequest} adminemojiAliasAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasAdd: async (aliasFor: string, name: string, token: string, adminemojiAliasAddRequest: AdminemojiAliasAddRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasFor' is not null or undefined
            assertParamExists('aliasAdd', 'aliasFor', aliasFor)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('aliasAdd', 'name', name)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('aliasAdd', 'token', token)
            // verify required parameter 'adminemojiAliasAddRequest' is not null or undefined
            assertParamExists('aliasAdd', 'adminemojiAliasAddRequest', adminemojiAliasAddRequest)
            const localVarPath = `/admin.emoji.addAlias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (aliasFor !== undefined) {
                await addFormParam('alias_for', aliasFor, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminemojiAliasAddRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.emoji.addAlias',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminemojiAliasAddRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve an app for installation on a workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
         * @param {string} [appId] The id of the app to approve.
         * @param {string} [requestId] The id of the request to approve.
         * @param {string} [teamId] 
         * @param {AdminappsApproveAppInstallationRequest} [adminappsApproveAppInstallationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAppInstallation: async (token: string, appId?: string, requestId?: string, teamId?: string, adminappsApproveAppInstallationRequest?: AdminappsApproveAppInstallationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('approveAppInstallation', 'token', token)
            const localVarPath = `/admin.apps.approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.apps:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (appId !== undefined) {
                await addFormParam('app_id', appId, false, true)
            }
    
            if (requestId !== undefined) {
                await addFormParam('request_id', requestId, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminappsApproveAppInstallationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.apps.approve',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminappsApproveAppInstallationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve a workspace invite request.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
         * @param {AdmininviteRequestsApproveRequestRequest} [admininviteRequestsApproveRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveRequest: async (token: string, admininviteRequestsApproveRequestRequest?: AdmininviteRequestsApproveRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('approveRequest', 'token', token)
            const localVarPath = `/admin.inviteRequests.approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.invites:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: admininviteRequestsApproveRequestRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.inviteRequests.approve',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(admininviteRequestsApproveRequestRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to archive.
         * @param {AdminconversationsArchiveChannelRequest} adminconversationsArchiveChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChannel: async (token: string, channelId: string, adminconversationsArchiveChannelRequest: AdminconversationsArchiveChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('archiveChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('archiveChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsArchiveChannelRequest' is not null or undefined
            assertParamExists('archiveChannel', 'adminconversationsArchiveChannelRequest', adminconversationsArchiveChannelRequest)
            const localVarPath = `/admin.conversations.archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsArchiveChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.archive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsArchiveChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Associate one or more default workspaces with an organization-wide IDP group.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} teamIds A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
         * @param {string} usergroupId An encoded usergroup (IDP Group) ID.
         * @param {AdminusergroupsAssociateDefaultWorkspacesRequest} adminusergroupsAssociateDefaultWorkspacesRequest 
         * @param {boolean} [autoProvision] When &#x60;true&#x60;, this method automatically creates new workspace accounts for the IDP group members.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateDefaultWorkspaces: async (token: string, teamIds: string, usergroupId: string, adminusergroupsAssociateDefaultWorkspacesRequest: AdminusergroupsAssociateDefaultWorkspacesRequest, autoProvision?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('associateDefaultWorkspaces', 'token', token)
            // verify required parameter 'teamIds' is not null or undefined
            assertParamExists('associateDefaultWorkspaces', 'teamIds', teamIds)
            // verify required parameter 'usergroupId' is not null or undefined
            assertParamExists('associateDefaultWorkspaces', 'usergroupId', usergroupId)
            // verify required parameter 'adminusergroupsAssociateDefaultWorkspacesRequest' is not null or undefined
            assertParamExists('associateDefaultWorkspaces', 'adminusergroupsAssociateDefaultWorkspacesRequest', adminusergroupsAssociateDefaultWorkspacesRequest)
            const localVarPath = `/admin.usergroups.addTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (autoProvision !== undefined) {
                await addFormParam('auto_provision', autoProvision, false, true)
            }
    
            if (teamIds !== undefined) {
                await addFormParam('team_ids', teamIds, false, true)
            }
    
            if (usergroupId !== undefined) {
                await addFormParam('usergroup_id', usergroupId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusergroupsAssociateDefaultWorkspacesRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.usergroups.addTeams',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusergroupsAssociateDefaultWorkspacesRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert a public channel to a private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to convert to private.
         * @param {AdminconversationsConvertToPrivateChannelRequest} adminconversationsConvertToPrivateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPrivateChannel: async (token: string, channelId: string, adminconversationsConvertToPrivateChannelRequest: AdminconversationsConvertToPrivateChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsConvertToPrivateChannelRequest' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'adminconversationsConvertToPrivateChannelRequest', adminconversationsConvertToPrivateChannelRequest)
            const localVarPath = `/admin.conversations.convertToPrivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsConvertToPrivateChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.convertToPrivate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsConvertToPrivateChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {boolean} isPrivate When &#x60;true&#x60;, creates a private channel instead of a public channel
         * @param {string} name Name of the public or private channel to create.
         * @param {AdminconversationsCreateChannelBasedConversationRequest} adminconversationsCreateChannelBasedConversationRequest 
         * @param {string} [description] Description of the public or private channel to create.
         * @param {boolean} [orgWide] When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel
         * @param {string} [teamId] The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelBasedConversation: async (token: string, isPrivate: boolean, name: string, adminconversationsCreateChannelBasedConversationRequest: AdminconversationsCreateChannelBasedConversationRequest, description?: string, orgWide?: boolean, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'token', token)
            // verify required parameter 'isPrivate' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'isPrivate', isPrivate)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'name', name)
            // verify required parameter 'adminconversationsCreateChannelBasedConversationRequest' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'adminconversationsCreateChannelBasedConversationRequest', adminconversationsCreateChannelBasedConversationRequest)
            const localVarPath = `/admin.conversations.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (description !== undefined) {
                await addFormParam('description', description, false, true)
            }
    
            if (isPrivate !== undefined) {
                await addFormParam('is_private', isPrivate, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (orgWide !== undefined) {
                await addFormParam('org_wide', orgWide, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsCreateChannelBasedConversationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.create',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsCreateChannelBasedConversationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Enterprise team.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} teamDomain Team domain (for example, slacksoftballteam).
         * @param {string} teamName Team name (for example, Slack Softball Team).
         * @param {AdminteamsCreateEnterpriseTeamRequest} adminteamsCreateEnterpriseTeamRequest 
         * @param {string} [teamDescription] Description for the team.
         * @param {string} [teamDiscoverability] Who can join the team. A team\\\&#39;s discoverability can be &#x60;open&#x60;, &#x60;closed&#x60;, &#x60;invite_only&#x60;, or &#x60;unlisted&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseTeam: async (token: string, teamDomain: string, teamName: string, adminteamsCreateEnterpriseTeamRequest: AdminteamsCreateEnterpriseTeamRequest, teamDescription?: string, teamDiscoverability?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('createEnterpriseTeam', 'token', token)
            // verify required parameter 'teamDomain' is not null or undefined
            assertParamExists('createEnterpriseTeam', 'teamDomain', teamDomain)
            // verify required parameter 'teamName' is not null or undefined
            assertParamExists('createEnterpriseTeam', 'teamName', teamName)
            // verify required parameter 'adminteamsCreateEnterpriseTeamRequest' is not null or undefined
            assertParamExists('createEnterpriseTeam', 'adminteamsCreateEnterpriseTeamRequest', adminteamsCreateEnterpriseTeamRequest)
            const localVarPath = `/admin.teams.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (teamDescription !== undefined) {
                await addFormParam('team_description', teamDescription, false, true)
            }
    
            if (teamDiscoverability !== undefined) {
                await addFormParam('team_discoverability', teamDiscoverability, false, true)
            }
    
            if (teamDomain !== undefined) {
                await addFormParam('team_domain', teamDomain, false, true)
            }
    
            if (teamName !== undefined) {
                await addFormParam('team_name', teamName, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamsCreateEnterpriseTeamRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.create',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamsCreateEnterpriseTeamRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to delete.
         * @param {AdminconversationsDeleteChannelRequest} adminconversationsDeleteChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel: async (token: string, channelId: string, adminconversationsDeleteChannelRequest: AdminconversationsDeleteChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsDeleteChannelRequest' is not null or undefined
            assertParamExists('deleteChannel', 'adminconversationsDeleteChannelRequest', adminconversationsDeleteChannelRequest)
            const localVarPath = `/admin.conversations.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsDeleteChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.delete',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsDeleteChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deny a workspace invite request.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.invites:write&#x60;
         * @param {AdmininviteRequestsApproveRequestRequest} [admininviteRequestsApproveRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyRequest: async (token: string, admininviteRequestsApproveRequestRequest?: AdmininviteRequestsApproveRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('denyRequest', 'token', token)
            const localVarPath = `/admin.inviteRequests.deny`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.invites:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: admininviteRequestsApproveRequestRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.inviteRequests.deny',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(admininviteRequestsApproveRequestRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to be disconnected from some workspaces.
         * @param {AdminconversationsDisconnectSharedChannelRequest} adminconversationsDisconnectSharedChannelRequest 
         * @param {string} [leavingTeamIds] The team to be removed from the channel. Currently only a single team id can be specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSharedChannel: async (token: string, channelId: string, adminconversationsDisconnectSharedChannelRequest: AdminconversationsDisconnectSharedChannelRequest, leavingTeamIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsDisconnectSharedChannelRequest' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'adminconversationsDisconnectSharedChannelRequest', adminconversationsDisconnectSharedChannelRequest)
            const localVarPath = `/admin.conversations.disconnectShared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (leavingTeamIds !== undefined) {
                await addFormParam('leaving_team_ids', leavingTeamIds, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsDisconnectSharedChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.disconnectShared',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsDisconnectSharedChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the admins on a given workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
         * @param {string} teamId 
         * @param {number} [limit] The maximum number of items to return.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (token: string, teamId: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAll', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getAll', 'teamId', teamId)
            const localVarPath = `/admin.teams.admins.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.admins.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} channelId The channel to get preferences for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationPrefs: async (token: string, channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getConversationPrefs', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getConversationPrefs', 'channelId', channelId)
            const localVarPath = `/admin.conversations.getConversationPrefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.getConversationPrefs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch information about settings in a workspace
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (token: string, teamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getInfo', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getInfo', 'teamId', teamId)
            const localVarPath = `/admin.teams.settings.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:read"], configuration)
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List restricted apps for an org or workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {string} [teamId] 
         * @param {string} [enterpriseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList: async (token: string, limit?: number, cursor?: string, teamId?: string, enterpriseId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getList', 'token', token)
            const localVarPath = `/admin.apps.restricted.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.apps:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (enterpriseId !== undefined) {
                localVarQueryParameter['enterprise_id'] = enterpriseId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.apps.restricted.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} channelId The channel to determine connected workspaces within the organization for.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsList: async (token: string, channelId: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getTeamsList', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getTeamsList', 'channelId', channelId)
            const localVarPath = `/admin.conversations.getTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.getTeams',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate a single session for a user by session_id
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {number} sessionId 
         * @param {string} teamId ID of the team that the session belongs to
         * @param {AdminuserssessionInvalidateSessionRequest} adminuserssessionInvalidateSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateSession: async (token: string, sessionId: number, teamId: string, adminuserssessionInvalidateSessionRequest: AdminuserssessionInvalidateSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('invalidateSession', 'token', token)
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('invalidateSession', 'sessionId', sessionId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('invalidateSession', 'teamId', teamId)
            // verify required parameter 'adminuserssessionInvalidateSessionRequest' is not null or undefined
            assertParamExists('invalidateSession', 'adminuserssessionInvalidateSessionRequest', adminuserssessionInvalidateSessionRequest)
            const localVarPath = `/admin.users.session.invalidate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (sessionId !== undefined) {
                await addFormParam('session_id', sessionId, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminuserssessionInvalidateSessionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.session.invalidate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminuserssessionInvalidateSessionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel that the users will be invited to.
         * @param {string} userIds The users to invite.
         * @param {AdminconversationsInviteUserToChannelRequest} adminconversationsInviteUserToChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToChannel: async (token: string, channelId: string, userIds: string, adminconversationsInviteUserToChannelRequest: AdminconversationsInviteUserToChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('inviteUserToChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('inviteUserToChannel', 'channelId', channelId)
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('inviteUserToChannel', 'userIds', userIds)
            // verify required parameter 'adminconversationsInviteUserToChannelRequest' is not null or undefined
            assertParamExists('inviteUserToChannel', 'adminconversationsInviteUserToChannelRequest', adminconversationsInviteUserToChannelRequest)
            const localVarPath = `/admin.conversations.invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (userIds !== undefined) {
                await addFormParam('user_ids', userIds, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsInviteUserToChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.invite',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsInviteUserToChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to a workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} channelIds A comma-separated list of &#x60;channel_id&#x60;s for this user to join. At least one channel is required.
         * @param {string} email The email address of the person to invite.
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {AdminusersInviteUserToWorkspaceRequest} adminusersInviteUserToWorkspaceRequest 
         * @param {string} [customMessage] An optional message to send to the user in the invite email.
         * @param {string} [guestExpirationTs] Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date.
         * @param {boolean} [isRestricted] Is this user a multi-channel guest user? (default: false)
         * @param {boolean} [isUltraRestricted] Is this user a single channel guest user? (default: false)
         * @param {string} [realName] Full name of the user.
         * @param {boolean} [resend] Allow this invite to be resent in the future if a user has not signed up yet. (default: false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToWorkspace: async (token: string, channelIds: string, email: string, teamId: string, adminusersInviteUserToWorkspaceRequest: AdminusersInviteUserToWorkspaceRequest, customMessage?: string, guestExpirationTs?: string, isRestricted?: boolean, isUltraRestricted?: boolean, realName?: string, resend?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('inviteUserToWorkspace', 'token', token)
            // verify required parameter 'channelIds' is not null or undefined
            assertParamExists('inviteUserToWorkspace', 'channelIds', channelIds)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('inviteUserToWorkspace', 'email', email)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('inviteUserToWorkspace', 'teamId', teamId)
            // verify required parameter 'adminusersInviteUserToWorkspaceRequest' is not null or undefined
            assertParamExists('inviteUserToWorkspace', 'adminusersInviteUserToWorkspaceRequest', adminusersInviteUserToWorkspaceRequest)
            const localVarPath = `/admin.users.invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelIds !== undefined) {
                await addFormParam('channel_ids', channelIds, false, true)
            }
    
            if (customMessage !== undefined) {
                await addFormParam('custom_message', customMessage, false, true)
            }
    
            if (email !== undefined) {
                await addFormParam('email', email, false, true)
            }
    
            if (guestExpirationTs !== undefined) {
                await addFormParam('guest_expiration_ts', guestExpirationTs, false, true)
            }
    
            if (isRestricted !== undefined) {
                await addFormParam('is_restricted', isRestricted, false, true)
            }
    
            if (isUltraRestricted !== undefined) {
                await addFormParam('is_ultra_restricted', isUltraRestricted, false, true)
            }
    
            if (realName !== undefined) {
                await addFormParam('real_name', realName, false, true)
            }
    
            if (resend !== undefined) {
                await addFormParam('resend', resend, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersInviteUserToWorkspaceRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.invite',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersInviteUserToWorkspaceRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List approved apps for an org or workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {string} [teamId] 
         * @param {string} [enterpriseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (token: string, limit?: number, cursor?: string, teamId?: string, enterpriseId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('list', 'token', token)
            const localVarPath = `/admin.apps.approved.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.apps:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (enterpriseId !== undefined) {
                localVarQueryParameter['enterprise_id'] = enterpriseId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.apps.approved.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all teams on an Enterprise organization
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 100 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll: async (token: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listAll', 'token', token)
            const localVarPath = `/admin.teams.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:read"], configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the channels linked to an org-level IDP group (user group).
         * @param {string} token Authentication token. Requires scope: &#x60;admin.usergroups:read&#x60;
         * @param {string} usergroupId ID of the IDP group to list default channels for.
         * @param {string} [teamId] ID of the the workspace.
         * @param {boolean} [includeNumMembers] Flag to include or exclude the count of members per channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelsGet: async (token: string, usergroupId: string, teamId?: string, includeNumMembers?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listChannelsGet', 'token', token)
            // verify required parameter 'usergroupId' is not null or undefined
            assertParamExists('listChannelsGet', 'usergroupId', usergroupId)
            const localVarPath = `/admin.usergroups.listChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.usergroups:read"], configuration)
            if (usergroupId !== undefined) {
                localVarQueryParameter['usergroup_id'] = usergroupId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (includeNumMembers !== undefined) {
                localVarQueryParameter['include_num_members'] = includeNumMembers;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.usergroups.listChannels',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emoji for an Enterprise Grid organization.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseEmoji: async (token: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listEnterpriseEmoji', 'token', token)
            const localVarPath = `/admin.emoji.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.emoji.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all IDP Groups linked to a channel
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} channelId 
         * @param {string} [teamId] The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (token: string, channelId: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listGroups', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('listGroups', 'channelId', channelId)
            const localVarPath = `/admin.conversations.restrictAccess.listGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.restrictAccess.listGroups',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} [channelIds] A comma-separated list of channels to filter to.
         * @param {string} [teamIds] A comma-separated list of the workspaces to which the channels you would like returned belong.
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOriginalConnectedChannelInfo: async (token: string, channelIds?: string, teamIds?: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listOriginalConnectedChannelInfo', 'token', token)
            const localVarPath = `/admin.conversations.ekm.listOriginalConnectedChannelInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channel_ids'] = channelIds;
            }

            if (teamIds !== undefined) {
                localVarQueryParameter['team_ids'] = teamIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.ekm.listOriginalConnectedChannelInfo',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the owners on a given workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:read&#x60;
         * @param {string} teamId 
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwners: async (token: string, teamId: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listOwners', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listOwners', 'teamId', teamId)
            const localVarPath = `/admin.teams.owners.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.owners.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all pending workspace invite requests.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
         * @param {string} [teamId] ID for the workspace where the invite requests were made.
         * @param {string} [cursor] Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response
         * @param {number} [limit] The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingWorkspaceInviteRequests: async (token: string, teamId?: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listPendingWorkspaceInviteRequests', 'token', token)
            const localVarPath = `/admin.inviteRequests.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.invites:read"], configuration)
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.inviteRequests.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users on a workspace
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:read&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {number} [limit] Limit for how many users to be retrieved per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers: async (token: string, teamId: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listWorkspaceUsers', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listWorkspaceUsers', 'teamId', teamId)
            const localVarPath = `/admin.users.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:read"], configuration)
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List app requests for a team/workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.apps:read&#x60;
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {string} [teamId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_1: async (token: string, limit?: number, cursor?: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('list_1', 'token', token)
            const localVarPath = `/admin.apps.requests.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.apps:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.apps.requests.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all approved workspace invite requests.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
         * @param {string} [teamId] ID for the workspace where the invite requests were made.
         * @param {string} [cursor] Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response
         * @param {number} [limit] The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_2: async (token: string, teamId?: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('list_2', 'token', token)
            const localVarPath = `/admin.inviteRequests.approved.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.invites:read"], configuration)
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.inviteRequests.approved.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all denied workspace invite requests.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.invites:read&#x60;
         * @param {string} [teamId] ID for the workspace where the invite requests were made.
         * @param {string} [cursor] Value of the &#x60;next_cursor&#x60; field sent as part of the previous api response
         * @param {number} [limit] The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_3: async (token: string, teamId?: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('list_3', 'token', token)
            const localVarPath = `/admin.inviteRequests.denied.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.invites:read"], configuration)
            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.inviteRequests.denied.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove one or more default channels from an org-level IDP group (user group).
         * @param {string} token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60;
         * @param {string} channelIds Comma-separated string of channel IDs
         * @param {string} usergroupId ID of the IDP Group
         * @param {AdminusergroupsRemoveChannelsRequest} adminusergroupsRemoveChannelsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannels: async (token: string, channelIds: string, usergroupId: string, adminusergroupsRemoveChannelsRequest: AdminusergroupsRemoveChannelsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('removeChannels', 'token', token)
            // verify required parameter 'channelIds' is not null or undefined
            assertParamExists('removeChannels', 'channelIds', channelIds)
            // verify required parameter 'usergroupId' is not null or undefined
            assertParamExists('removeChannels', 'usergroupId', usergroupId)
            // verify required parameter 'adminusergroupsRemoveChannelsRequest' is not null or undefined
            assertParamExists('removeChannels', 'adminusergroupsRemoveChannelsRequest', adminusergroupsRemoveChannelsRequest)
            const localVarPath = `/admin.usergroups.removeChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.usergroups:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelIds !== undefined) {
                await addFormParam('channel_ids', channelIds, false, true)
            }
    
            if (usergroupId !== undefined) {
                await addFormParam('usergroup_id', usergroupId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusergroupsRemoveChannelsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.usergroups.removeChannels',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusergroupsRemoveChannelsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an emoji across an Enterprise Grid organization
         * @param {string} name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {AdminemojiRemoveEnterpriseEmojiRequest} adminemojiRemoveEnterpriseEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEnterpriseEmoji: async (name: string, token: string, adminemojiRemoveEnterpriseEmojiRequest: AdminemojiRemoveEnterpriseEmojiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('removeEnterpriseEmoji', 'name', name)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('removeEnterpriseEmoji', 'token', token)
            // verify required parameter 'adminemojiRemoveEnterpriseEmojiRequest' is not null or undefined
            assertParamExists('removeEnterpriseEmoji', 'adminemojiRemoveEnterpriseEmojiRequest', adminemojiRemoveEnterpriseEmojiRequest)
            const localVarPath = `/admin.emoji.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminemojiRemoveEnterpriseEmojiRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.emoji.remove',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminemojiRemoveEnterpriseEmojiRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a linked IDP group linked from a private channel
         * @param {string} channelId The channel to remove the linked group from.
         * @param {string} groupId The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel.
         * @param {string} teamId The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {AdminconversationsrestrictAccessRemoveIdpGroupRequest} adminconversationsrestrictAccessRemoveIdpGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeIdpGroup: async (channelId: string, groupId: string, teamId: string, token: string, adminconversationsrestrictAccessRemoveIdpGroupRequest: AdminconversationsrestrictAccessRemoveIdpGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('removeIdpGroup', 'channelId', channelId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeIdpGroup', 'groupId', groupId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeIdpGroup', 'teamId', teamId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('removeIdpGroup', 'token', token)
            // verify required parameter 'adminconversationsrestrictAccessRemoveIdpGroupRequest' is not null or undefined
            assertParamExists('removeIdpGroup', 'adminconversationsrestrictAccessRemoveIdpGroupRequest', adminconversationsrestrictAccessRemoveIdpGroupRequest)
            const localVarPath = `/admin.conversations.restrictAccess.removeGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)

            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (groupId !== undefined) {
                await addFormParam('group_id', groupId, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsrestrictAccessRemoveIdpGroupRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.restrictAccess.removeGroup',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsrestrictAccessRemoveIdpGroupRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user from a workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId The ID of the user to remove.
         * @param {AdminusersRemoveUserFromWorkspaceRequest} adminusersRemoveUserFromWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromWorkspace: async (token: string, teamId: string, userId: string, adminusersRemoveUserFromWorkspaceRequest: AdminusersRemoveUserFromWorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('removeUserFromWorkspace', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeUserFromWorkspace', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromWorkspace', 'userId', userId)
            // verify required parameter 'adminusersRemoveUserFromWorkspaceRequest' is not null or undefined
            assertParamExists('removeUserFromWorkspace', 'adminusersRemoveUserFromWorkspaceRequest', adminusersRemoveUserFromWorkspaceRequest)
            const localVarPath = `/admin.users.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersRemoveUserFromWorkspaceRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.remove',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersRemoveUserFromWorkspaceRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to rename.
         * @param {string} name 
         * @param {AdminconversationsRenameChannelRequest} adminconversationsRenameChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameChannel: async (token: string, channelId: string, name: string, adminconversationsRenameChannelRequest: AdminconversationsRenameChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('renameChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('renameChannel', 'channelId', channelId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('renameChannel', 'name', name)
            // verify required parameter 'adminconversationsRenameChannelRequest' is not null or undefined
            assertParamExists('renameChannel', 'adminconversationsRenameChannelRequest', adminconversationsRenameChannelRequest)
            const localVarPath = `/admin.conversations.rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsRenameChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.rename',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsRenameChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename an emoji.
         * @param {string} name The name of the emoji to be renamed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included.
         * @param {string} newName The new name of the emoji.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {AdminemojiRenameEmojiRequest} adminemojiRenameEmojiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameEmoji: async (name: string, newName: string, token: string, adminemojiRenameEmojiRequest: AdminemojiRenameEmojiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('renameEmoji', 'name', name)
            // verify required parameter 'newName' is not null or undefined
            assertParamExists('renameEmoji', 'newName', newName)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('renameEmoji', 'token', token)
            // verify required parameter 'adminemojiRenameEmojiRequest' is not null or undefined
            assertParamExists('renameEmoji', 'adminemojiRenameEmojiRequest', adminemojiRenameEmojiRequest)
            const localVarPath = `/admin.emoji.rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (newName !== undefined) {
                await addFormParam('new_name', newName, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminemojiRenameEmojiRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.emoji.rename',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminemojiRenameEmojiRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Wipes all valid sessions on all devices for a given user
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} userId The ID of the user to wipe sessions for
         * @param {AdminuserssessionResetSessionsRequest} adminuserssessionResetSessionsRequest 
         * @param {boolean} [mobileOnly] Only expire mobile sessions (default: false)
         * @param {boolean} [webOnly] Only expire web sessions (default: false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSessions: async (token: string, userId: string, adminuserssessionResetSessionsRequest: AdminuserssessionResetSessionsRequest, mobileOnly?: boolean, webOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('resetSessions', 'token', token)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('resetSessions', 'userId', userId)
            // verify required parameter 'adminuserssessionResetSessionsRequest' is not null or undefined
            assertParamExists('resetSessions', 'adminuserssessionResetSessionsRequest', adminuserssessionResetSessionsRequest)
            const localVarPath = `/admin.users.session.reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (mobileOnly !== undefined) {
                await addFormParam('mobile_only', mobileOnly, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
            if (webOnly !== undefined) {
                await addFormParam('web_only', webOnly, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminuserssessionResetSessionsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.session.reset',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminuserssessionResetSessionsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restrict an app for installation on a workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.apps:write&#x60;
         * @param {string} [appId] The id of the app to restrict.
         * @param {string} [requestId] The id of the request to restrict.
         * @param {string} [teamId] 
         * @param {AdminappsRestrictAppRequest} [adminappsRestrictAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restrictApp: async (token: string, appId?: string, requestId?: string, teamId?: string, adminappsRestrictAppRequest?: AdminappsRestrictAppRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('restrictApp', 'token', token)
            const localVarPath = `/admin.apps.restrict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.apps:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (appId !== undefined) {
                await addFormParam('app_id', appId, false, true)
            }
    
            if (requestId !== undefined) {
                await addFormParam('request_id', requestId, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminappsRestrictAppRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.apps.restrict',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminappsRestrictAppRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} [teamIds] Comma separated string of team IDs, signifying the workspaces to search through.
         * @param {string} [query] Name of the the channel to query by.
         * @param {number} [limit] Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {string} [searchChannelTypes] The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](https://slack.dev).
         * @param {string} [sort] Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted 
         * @param {string} [sortDir] Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChannels: async (token: string, teamIds?: string, query?: string, limit?: number, cursor?: string, searchChannelTypes?: string, sort?: string, sortDir?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('searchChannels', 'token', token)
            const localVarPath = `/admin.conversations.search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (teamIds !== undefined) {
                localVarQueryParameter['team_ids'] = teamIds;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (searchChannelTypes !== undefined) {
                localVarQueryParameter['search_channel_types'] = searchChannelTypes;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an existing guest, regular user, or owner to be an admin user.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId The ID of the user to designate as an admin.
         * @param {AdminusersSetAdminUserRequest} adminusersSetAdminUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAdminUser: async (token: string, teamId: string, userId: string, adminusersSetAdminUserRequest: AdminusersSetAdminUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setAdminUser', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setAdminUser', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setAdminUser', 'userId', userId)
            // verify required parameter 'adminusersSetAdminUserRequest' is not null or undefined
            assertParamExists('setAdminUser', 'adminusersSetAdminUserRequest', adminusersSetAdminUserRequest)
            const localVarPath = `/admin.users.setAdmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersSetAdminUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.setAdmin',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersSetAdminUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to set the prefs for
         * @param {string} prefs The prefs for this channel in a stringified JSON format.
         * @param {AdminconversationsSetConversationPrefsRequest} adminconversationsSetConversationPrefsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConversationPrefs: async (token: string, channelId: string, prefs: string, adminconversationsSetConversationPrefsRequest: AdminconversationsSetConversationPrefsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setConversationPrefs', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setConversationPrefs', 'channelId', channelId)
            // verify required parameter 'prefs' is not null or undefined
            assertParamExists('setConversationPrefs', 'prefs', prefs)
            // verify required parameter 'adminconversationsSetConversationPrefsRequest' is not null or undefined
            assertParamExists('setConversationPrefs', 'adminconversationsSetConversationPrefsRequest', adminconversationsSetConversationPrefsRequest)
            const localVarPath = `/admin.conversations.setConversationPrefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (prefs !== undefined) {
                await addFormParam('prefs', prefs, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsSetConversationPrefsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.setConversationPrefs',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsSetConversationPrefsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the default channels of a workspace.
         * @param {string} channelIds An array of channel IDs.
         * @param {string} teamId ID for the workspace to set the default channel for.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {AdminteamssettingsSetDefaultChannelsRequest} adminteamssettingsSetDefaultChannelsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultChannels: async (channelIds: string, teamId: string, token: string, adminteamssettingsSetDefaultChannelsRequest: AdminteamssettingsSetDefaultChannelsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelIds' is not null or undefined
            assertParamExists('setDefaultChannels', 'channelIds', channelIds)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setDefaultChannels', 'teamId', teamId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setDefaultChannels', 'token', token)
            // verify required parameter 'adminteamssettingsSetDefaultChannelsRequest' is not null or undefined
            assertParamExists('setDefaultChannels', 'adminteamssettingsSetDefaultChannelsRequest', adminteamssettingsSetDefaultChannelsRequest)
            const localVarPath = `/admin.teams.settings.setDefaultChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (channelIds !== undefined) {
                await addFormParam('channel_ids', channelIds, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamssettingsSetDefaultChannelsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.setDefaultChannels',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamssettingsSetDefaultChannelsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the description of a given workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} description The new description for the workspace.
         * @param {string} teamId ID for the workspace to set the description for.
         * @param {AdminteamssettingsSetDescriptionRequest} adminteamssettingsSetDescriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDescription: async (token: string, description: string, teamId: string, adminteamssettingsSetDescriptionRequest: AdminteamssettingsSetDescriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setDescription', 'token', token)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('setDescription', 'description', description)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setDescription', 'teamId', teamId)
            // verify required parameter 'adminteamssettingsSetDescriptionRequest' is not null or undefined
            assertParamExists('setDescription', 'adminteamssettingsSetDescriptionRequest', adminteamssettingsSetDescriptionRequest)
            const localVarPath = `/admin.teams.settings.setDescription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (description !== undefined) {
                await addFormParam('description', description, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamssettingsSetDescriptionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.setDescription',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamssettingsSetDescriptionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An API method that allows admins to set the discoverability of a given workspace
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} discoverability This workspace\\\&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;.
         * @param {string} teamId The ID of the workspace to set discoverability on.
         * @param {AdminteamssettingsSetDiscoverabilityOfWorkspaceRequest} adminteamssettingsSetDiscoverabilityOfWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiscoverabilityOfWorkspace: async (token: string, discoverability: string, teamId: string, adminteamssettingsSetDiscoverabilityOfWorkspaceRequest: AdminteamssettingsSetDiscoverabilityOfWorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setDiscoverabilityOfWorkspace', 'token', token)
            // verify required parameter 'discoverability' is not null or undefined
            assertParamExists('setDiscoverabilityOfWorkspace', 'discoverability', discoverability)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setDiscoverabilityOfWorkspace', 'teamId', teamId)
            // verify required parameter 'adminteamssettingsSetDiscoverabilityOfWorkspaceRequest' is not null or undefined
            assertParamExists('setDiscoverabilityOfWorkspace', 'adminteamssettingsSetDiscoverabilityOfWorkspaceRequest', adminteamssettingsSetDiscoverabilityOfWorkspaceRequest)
            const localVarPath = `/admin.teams.settings.setDiscoverability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (discoverability !== undefined) {
                await addFormParam('discoverability', discoverability, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamssettingsSetDiscoverabilityOfWorkspaceRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.setDiscoverability',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamssettingsSetDiscoverabilityOfWorkspaceRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an expiration for a guest user
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {number} expirationTs Timestamp when guest account should be disabled.
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId The ID of the user to set an expiration for.
         * @param {AdminusersSetExpirationGuestRequest} adminusersSetExpirationGuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExpirationGuest: async (token: string, expirationTs: number, teamId: string, userId: string, adminusersSetExpirationGuestRequest: AdminusersSetExpirationGuestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setExpirationGuest', 'token', token)
            // verify required parameter 'expirationTs' is not null or undefined
            assertParamExists('setExpirationGuest', 'expirationTs', expirationTs)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setExpirationGuest', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setExpirationGuest', 'userId', userId)
            // verify required parameter 'adminusersSetExpirationGuestRequest' is not null or undefined
            assertParamExists('setExpirationGuest', 'adminusersSetExpirationGuestRequest', adminusersSetExpirationGuestRequest)
            const localVarPath = `/admin.users.setExpiration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (expirationTs !== undefined) {
                await addFormParam('expiration_ts', expirationTs, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersSetExpirationGuestRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.setExpiration',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersSetExpirationGuestRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the icon of a workspace.
         * @param {string} imageUrl Image URL for the icon
         * @param {string} teamId ID for the workspace to set the icon for.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {AdminteamssettingsSetIconRequest} adminteamssettingsSetIconRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIcon: async (imageUrl: string, teamId: string, token: string, adminteamssettingsSetIconRequest: AdminteamssettingsSetIconRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            assertParamExists('setIcon', 'imageUrl', imageUrl)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setIcon', 'teamId', teamId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setIcon', 'token', token)
            // verify required parameter 'adminteamssettingsSetIconRequest' is not null or undefined
            assertParamExists('setIcon', 'adminteamssettingsSetIconRequest', adminteamssettingsSetIconRequest)
            const localVarPath = `/admin.teams.settings.setIcon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)

            if (imageUrl !== undefined) {
                await addFormParam('image_url', imageUrl, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamssettingsSetIconRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.setIcon',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamssettingsSetIconRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the name of a given workspace.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.teams:write&#x60;
         * @param {string} name The new name of the workspace.
         * @param {string} teamId ID for the workspace to set the name for.
         * @param {AdminteamssettingsSetNameRequest} adminteamssettingsSetNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName: async (token: string, name: string, teamId: string, adminteamssettingsSetNameRequest: AdminteamssettingsSetNameRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setName', 'token', token)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('setName', 'name', name)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setName', 'teamId', teamId)
            // verify required parameter 'adminteamssettingsSetNameRequest' is not null or undefined
            assertParamExists('setName', 'adminteamssettingsSetNameRequest', adminteamssettingsSetNameRequest)
            const localVarPath = `/admin.teams.settings.setName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.teams:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminteamssettingsSetNameRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.teams.settings.setName',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminteamssettingsSetNameRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an existing guest user, admin user, or owner to be a regular user.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId The ID of the user to designate as a regular user.
         * @param {AdminusersSetRegularUserRequest} adminusersSetRegularUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRegularUser: async (token: string, teamId: string, userId: string, adminusersSetRegularUserRequest: AdminusersSetRegularUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setRegularUser', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setRegularUser', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setRegularUser', 'userId', userId)
            // verify required parameter 'adminusersSetRegularUserRequest' is not null or undefined
            assertParamExists('setRegularUser', 'adminusersSetRegularUserRequest', adminusersSetRegularUserRequest)
            const localVarPath = `/admin.users.setRegular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersSetRegularUserRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.setRegular',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersSetRegularUserRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
         * @param {AdminconversationsSetTeamsWorkspaceConnectionRequest} adminconversationsSetTeamsWorkspaceConnectionRequest 
         * @param {boolean} [orgChannel] True if channel has to be converted to an org channel
         * @param {string} [targetTeamIds] A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
         * @param {string} [teamId] The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamsWorkspaceConnection: async (token: string, channelId: string, adminconversationsSetTeamsWorkspaceConnectionRequest: AdminconversationsSetTeamsWorkspaceConnectionRequest, orgChannel?: boolean, targetTeamIds?: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'channelId', channelId)
            // verify required parameter 'adminconversationsSetTeamsWorkspaceConnectionRequest' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'adminconversationsSetTeamsWorkspaceConnectionRequest', adminconversationsSetTeamsWorkspaceConnectionRequest)
            const localVarPath = `/admin.conversations.setTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (orgChannel !== undefined) {
                await addFormParam('org_channel', orgChannel, false, true)
            }
    
            if (targetTeamIds !== undefined) {
                await addFormParam('target_team_ids', targetTeamIds, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsSetTeamsWorkspaceConnectionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.setTeams',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsSetTeamsWorkspaceConnectionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an existing guest, regular user, or admin user to be a workspace owner.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.users:write&#x60;
         * @param {string} teamId The ID (&#x60;T1234&#x60;) of the workspace.
         * @param {string} userId Id of the user to promote to owner.
         * @param {AdminusersSetWorkspaceOwnerRequest} adminusersSetWorkspaceOwnerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceOwner: async (token: string, teamId: string, userId: string, adminusersSetWorkspaceOwnerRequest: AdminusersSetWorkspaceOwnerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setWorkspaceOwner', 'token', token)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setWorkspaceOwner', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setWorkspaceOwner', 'userId', userId)
            // verify required parameter 'adminusersSetWorkspaceOwnerRequest' is not null or undefined
            assertParamExists('setWorkspaceOwner', 'adminusersSetWorkspaceOwnerRequest', adminusersSetWorkspaceOwnerRequest)
            const localVarPath = `/admin.users.setOwner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminusersSetWorkspaceOwnerRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.users.setOwner',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminusersSetWorkspaceOwnerRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchive a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to unarchive.
         * @param {AdminconversationsUnarchiveChannelRequest} adminconversationsUnarchiveChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveChannel: async (token: string, channelId: string, adminconversationsUnarchiveChannelRequest: AdminconversationsUnarchiveChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('unarchiveChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('unarchiveChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsUnarchiveChannelRequest' is not null or undefined
            assertParamExists('unarchiveChannel', 'adminconversationsUnarchiveChannelRequest', adminconversationsUnarchiveChannelRequest)
            const localVarPath = `/admin.conversations.unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsUnarchiveChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.unarchive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsUnarchiveChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Add one or more default channels to an IDP group.
         * @param {AdminApiAddDefaultChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDefaultChannels(requestParameters: AdminApiAddDefaultChannelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusergroupsAddDefaultChannelsResponse>> {
            const adminusergroupsAddDefaultChannelsRequest: AdminusergroupsAddDefaultChannelsRequest = {
                channel_ids: requestParameters.channel_ids,
                team_id: requestParameters.team_id,
                usergroup_id: requestParameters.usergroup_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDefaultChannels(requestParameters.token, requestParameters.channelIds, requestParameters.usergroupId, adminusergroupsAddDefaultChannelsRequest, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an emoji.
         * @param {AdminApiAddEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEmoji(requestParameters: AdminApiAddEmojiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminemojiAddEmojiResponse>> {
            const adminemojiAddEmojiRequest: AdminemojiAddEmojiRequest = {
                name: requestParameters.name,
                token: requestParameters.token,
                url: requestParameters.url
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEmoji(requestParameters.name, requestParameters.token, requestParameters.url, adminemojiAddEmojiRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an allowlist of IDP groups for accessing a channel
         * @param {AdminApiAddGroupIdpGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupIdpGroups(requestParameters: AdminApiAddGroupIdpGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsrestrictAccessAddGroupIdpGroupsResponse>> {
            const adminconversationsrestrictAccessAddGroupIdpGroupsRequest: AdminconversationsrestrictAccessAddGroupIdpGroupsRequest = {
                channel_id: requestParameters.channel_id,
                group_id: requestParameters.group_id,
                team_id: requestParameters.team_id,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupIdpGroups(requestParameters.channelId, requestParameters.groupId, requestParameters.token, adminconversationsrestrictAccessAddGroupIdpGroupsRequest, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an Enterprise user to a workspace.
         * @param {AdminApiAddWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceUser(requestParameters: AdminApiAddWorkspaceUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersAddWorkspaceUserResponse>> {
            const adminusersAddWorkspaceUserRequest: AdminusersAddWorkspaceUserRequest = {
                channel_ids: requestParameters.channel_ids,
                is_restricted: requestParameters.is_restricted,
                is_ultra_restricted: requestParameters.is_ultra_restricted,
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceUser(requestParameters.token, requestParameters.teamId, requestParameters.userId, adminusersAddWorkspaceUserRequest, requestParameters.channelIds, requestParameters.isRestricted, requestParameters.isUltraRestricted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an emoji alias.
         * @param {AdminApiAliasAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aliasAdd(requestParameters: AdminApiAliasAddRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminemojiAliasAddResponse>> {
            const adminemojiAliasAddRequest: AdminemojiAliasAddRequest = {
                alias_for: requestParameters.alias_for,
                name: requestParameters.name,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.aliasAdd(requestParameters.aliasFor, requestParameters.name, requestParameters.token, adminemojiAliasAddRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve an app for installation on a workspace.
         * @param {AdminApiApproveAppInstallationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveAppInstallation(requestParameters: AdminApiApproveAppInstallationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminappsApproveAppInstallationResponse>> {
            const adminappsApproveAppInstallationRequest: AdminappsApproveAppInstallationRequest = {
                app_id: requestParameters.app_id,
                request_id: requestParameters.request_id,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveAppInstallation(requestParameters.token, requestParameters.appId, requestParameters.requestId, requestParameters.teamId, adminappsApproveAppInstallationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve a workspace invite request.
         * @param {AdminApiApproveRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveRequest(requestParameters: AdminApiApproveRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdmininviteRequestsApproveRequestResponse>> {
            const admininviteRequestsApproveRequestRequest: AdmininviteRequestsApproveRequestRequest = {
                invite_request_id: requestParameters.invite_request_id,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveRequest(requestParameters.token, admininviteRequestsApproveRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archive a public or private channel.
         * @param {AdminApiArchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveChannel(requestParameters: AdminApiArchiveChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsArchiveChannelResponse>> {
            const adminconversationsArchiveChannelRequest: AdminconversationsArchiveChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveChannel(requestParameters.token, requestParameters.channelId, adminconversationsArchiveChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Associate one or more default workspaces with an organization-wide IDP group.
         * @param {AdminApiAssociateDefaultWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associateDefaultWorkspaces(requestParameters: AdminApiAssociateDefaultWorkspacesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusergroupsAssociateDefaultWorkspacesResponse>> {
            const adminusergroupsAssociateDefaultWorkspacesRequest: AdminusergroupsAssociateDefaultWorkspacesRequest = {
                auto_provision: requestParameters.auto_provision,
                team_ids: requestParameters.team_ids,
                usergroup_id: requestParameters.usergroup_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.associateDefaultWorkspaces(requestParameters.token, requestParameters.teamIds, requestParameters.usergroupId, adminusergroupsAssociateDefaultWorkspacesRequest, requestParameters.autoProvision, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Convert a public channel to a private channel.
         * @param {AdminApiConvertToPrivateChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPrivateChannel(requestParameters: AdminApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsConvertToPrivateChannelResponse>> {
            const adminconversationsConvertToPrivateChannelRequest: AdminconversationsConvertToPrivateChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertToPrivateChannel(requestParameters.token, requestParameters.channelId, adminconversationsConvertToPrivateChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {AdminApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannelBasedConversation(requestParameters: AdminApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsCreateChannelBasedConversationResponse>> {
            const adminconversationsCreateChannelBasedConversationRequest: AdminconversationsCreateChannelBasedConversationRequest = {
                description: requestParameters.description,
                is_private: requestParameters.is_private,
                name: requestParameters.name,
                org_wide: requestParameters.org_wide,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChannelBasedConversation(requestParameters.token, requestParameters.isPrivate, requestParameters.name, adminconversationsCreateChannelBasedConversationRequest, requestParameters.description, requestParameters.orgWide, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an Enterprise team.
         * @param {AdminApiCreateEnterpriseTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnterpriseTeam(requestParameters: AdminApiCreateEnterpriseTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamsCreateEnterpriseTeamResponse>> {
            const adminteamsCreateEnterpriseTeamRequest: AdminteamsCreateEnterpriseTeamRequest = {
                team_description: requestParameters.team_description,
                team_discoverability: requestParameters.team_discoverability,
                team_domain: requestParameters.team_domain,
                team_name: requestParameters.team_name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnterpriseTeam(requestParameters.token, requestParameters.teamDomain, requestParameters.teamName, adminteamsCreateEnterpriseTeamRequest, requestParameters.teamDescription, requestParameters.teamDiscoverability, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public or private channel.
         * @param {AdminApiDeleteChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannel(requestParameters: AdminApiDeleteChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsDeleteChannelResponse>> {
            const adminconversationsDeleteChannelRequest: AdminconversationsDeleteChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(requestParameters.token, requestParameters.channelId, adminconversationsDeleteChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deny a workspace invite request.
         * @param {AdminApiDenyRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyRequest(requestParameters: AdminApiDenyRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdmininviteRequestsDenyRequestResponse>> {
            const admininviteRequestsApproveRequestRequest: AdmininviteRequestsApproveRequestRequest = {
                invite_request_id: requestParameters.invite_request_id,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyRequest(requestParameters.token, admininviteRequestsApproveRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {AdminApiDisconnectSharedChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectSharedChannel(requestParameters: AdminApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsDisconnectSharedChannelResponse>> {
            const adminconversationsDisconnectSharedChannelRequest: AdminconversationsDisconnectSharedChannelRequest = {
                channel_id: requestParameters.channel_id,
                leaving_team_ids: requestParameters.leaving_team_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectSharedChannel(requestParameters.token, requestParameters.channelId, adminconversationsDisconnectSharedChannelRequest, requestParameters.leavingTeamIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the admins on a given workspace.
         * @param {AdminApiGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(requestParameters: AdminApiGetAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamsadminsGetAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(requestParameters.token, requestParameters.teamId, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {AdminApiGetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationPrefs(requestParameters: AdminApiGetConversationPrefsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsGetConversationPrefsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationPrefs(requestParameters.token, requestParameters.channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch information about settings in a workspace
         * @param {AdminApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(requestParameters: AdminApiGetInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsGetInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(requestParameters.token, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List restricted apps for an org or workspace.
         * @param {AdminApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getList(requestParameters: AdminApiGetListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminappsrestrictedGetListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getList(requestParameters.token, requestParameters.limit, requestParameters.cursor, requestParameters.teamId, requestParameters.enterpriseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {AdminApiGetTeamsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsList(requestParameters: AdminApiGetTeamsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsGetTeamsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsList(requestParameters.token, requestParameters.channelId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invalidate a single session for a user by session_id
         * @param {AdminApiInvalidateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateSession(requestParameters: AdminApiInvalidateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminuserssessionInvalidateSessionResponse>> {
            const adminuserssessionInvalidateSessionRequest: AdminuserssessionInvalidateSessionRequest = {
                session_id: requestParameters.session_id,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateSession(requestParameters.token, requestParameters.sessionId, requestParameters.teamId, adminuserssessionInvalidateSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invite a user to a public or private channel.
         * @param {AdminApiInviteUserToChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserToChannel(requestParameters: AdminApiInviteUserToChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsInviteUserToChannelResponse>> {
            const adminconversationsInviteUserToChannelRequest: AdminconversationsInviteUserToChannelRequest = {
                channel_id: requestParameters.channel_id,
                user_ids: requestParameters.user_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserToChannel(requestParameters.token, requestParameters.channelId, requestParameters.userIds, adminconversationsInviteUserToChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invite a user to a workspace.
         * @param {AdminApiInviteUserToWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserToWorkspace(requestParameters: AdminApiInviteUserToWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersInviteUserToWorkspaceResponse>> {
            const adminusersInviteUserToWorkspaceRequest: AdminusersInviteUserToWorkspaceRequest = {
                channel_ids: requestParameters.channel_ids,
                custom_message: requestParameters.custom_message,
                email: requestParameters.email,
                guest_expiration_ts: requestParameters.guest_expiration_ts,
                is_restricted: requestParameters.is_restricted,
                is_ultra_restricted: requestParameters.is_ultra_restricted,
                real_name: requestParameters.real_name,
                resend: requestParameters.resend,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserToWorkspace(requestParameters.token, requestParameters.channelIds, requestParameters.email, requestParameters.teamId, adminusersInviteUserToWorkspaceRequest, requestParameters.customMessage, requestParameters.guestExpirationTs, requestParameters.isRestricted, requestParameters.isUltraRestricted, requestParameters.realName, requestParameters.resend, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List approved apps for an org or workspace.
         * @param {AdminApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: AdminApiListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminappsapprovedListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.token, requestParameters.limit, requestParameters.cursor, requestParameters.teamId, requestParameters.enterpriseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all teams on an Enterprise organization
         * @param {AdminApiListAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAll(requestParameters: AdminApiListAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamsListAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAll(requestParameters.token, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the channels linked to an org-level IDP group (user group).
         * @param {AdminApiListChannelsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChannelsGet(requestParameters: AdminApiListChannelsGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusergroupsListChannelsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChannelsGet(requestParameters.token, requestParameters.usergroupId, requestParameters.teamId, requestParameters.includeNumMembers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List emoji for an Enterprise Grid organization.
         * @param {AdminApiListEnterpriseEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnterpriseEmoji(requestParameters: AdminApiListEnterpriseEmojiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminemojiListEnterpriseEmojiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnterpriseEmoji(requestParameters.token, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all IDP Groups linked to a channel
         * @param {AdminApiListGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(requestParameters: AdminApiListGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsrestrictAccessListGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(requestParameters.token, requestParameters.channelId, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
         * @param {AdminApiListOriginalConnectedChannelInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOriginalConnectedChannelInfo(requestParameters: AdminApiListOriginalConnectedChannelInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsekmListOriginalConnectedChannelInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOriginalConnectedChannelInfo(requestParameters.token, requestParameters.channelIds, requestParameters.teamIds, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the owners on a given workspace.
         * @param {AdminApiListOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOwners(requestParameters: AdminApiListOwnersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamsownersListOwnersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOwners(requestParameters.token, requestParameters.teamId, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all pending workspace invite requests.
         * @param {AdminApiListPendingWorkspaceInviteRequestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPendingWorkspaceInviteRequests(requestParameters: AdminApiListPendingWorkspaceInviteRequestsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdmininviteRequestsListPendingWorkspaceInviteRequestsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPendingWorkspaceInviteRequests(requestParameters.token, requestParameters.teamId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users on a workspace
         * @param {AdminApiListWorkspaceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceUsers(requestParameters: AdminApiListWorkspaceUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersListWorkspaceUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceUsers(requestParameters.token, requestParameters.teamId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List app requests for a team/workspace.
         * @param {AdminApiList0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list_1(requestParameters: AdminApiList0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminappsrequestsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list_1(requestParameters.token, requestParameters.limit, requestParameters.cursor, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all approved workspace invite requests.
         * @param {AdminApiList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list_2(requestParameters: AdminApiList1Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdmininviteRequestsapprovedListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list_2(requestParameters.token, requestParameters.teamId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all denied workspace invite requests.
         * @param {AdminApiList2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list_3(requestParameters: AdminApiList2Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdmininviteRequestsdeniedListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list_3(requestParameters.token, requestParameters.teamId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove one or more default channels from an org-level IDP group (user group).
         * @param {AdminApiRemoveChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeChannels(requestParameters: AdminApiRemoveChannelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusergroupsRemoveChannelsResponse>> {
            const adminusergroupsRemoveChannelsRequest: AdminusergroupsRemoveChannelsRequest = {
                channel_ids: requestParameters.channel_ids,
                usergroup_id: requestParameters.usergroup_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeChannels(requestParameters.token, requestParameters.channelIds, requestParameters.usergroupId, adminusergroupsRemoveChannelsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an emoji across an Enterprise Grid organization
         * @param {AdminApiRemoveEnterpriseEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEnterpriseEmoji(requestParameters: AdminApiRemoveEnterpriseEmojiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminemojiRemoveEnterpriseEmojiResponse>> {
            const adminemojiRemoveEnterpriseEmojiRequest: AdminemojiRemoveEnterpriseEmojiRequest = {
                name: requestParameters.name,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEnterpriseEmoji(requestParameters.name, requestParameters.token, adminemojiRemoveEnterpriseEmojiRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a linked IDP group linked from a private channel
         * @param {AdminApiRemoveIdpGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeIdpGroup(requestParameters: AdminApiRemoveIdpGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsrestrictAccessRemoveIdpGroupResponse>> {
            const adminconversationsrestrictAccessRemoveIdpGroupRequest: AdminconversationsrestrictAccessRemoveIdpGroupRequest = {
                channel_id: requestParameters.channel_id,
                group_id: requestParameters.group_id,
                team_id: requestParameters.team_id,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeIdpGroup(requestParameters.channelId, requestParameters.groupId, requestParameters.teamId, requestParameters.token, adminconversationsrestrictAccessRemoveIdpGroupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a user from a workspace.
         * @param {AdminApiRemoveUserFromWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromWorkspace(requestParameters: AdminApiRemoveUserFromWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersRemoveUserFromWorkspaceResponse>> {
            const adminusersRemoveUserFromWorkspaceRequest: AdminusersRemoveUserFromWorkspaceRequest = {
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromWorkspace(requestParameters.token, requestParameters.teamId, requestParameters.userId, adminusersRemoveUserFromWorkspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rename a public or private channel.
         * @param {AdminApiRenameChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameChannel(requestParameters: AdminApiRenameChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsRenameChannelResponse>> {
            const adminconversationsRenameChannelRequest: AdminconversationsRenameChannelRequest = {
                channel_id: requestParameters.channel_id,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameChannel(requestParameters.token, requestParameters.channelId, requestParameters.name, adminconversationsRenameChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rename an emoji.
         * @param {AdminApiRenameEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameEmoji(requestParameters: AdminApiRenameEmojiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminemojiRenameEmojiResponse>> {
            const adminemojiRenameEmojiRequest: AdminemojiRenameEmojiRequest = {
                name: requestParameters.name,
                new_name: requestParameters.new_name,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameEmoji(requestParameters.name, requestParameters.newName, requestParameters.token, adminemojiRenameEmojiRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Wipes all valid sessions on all devices for a given user
         * @param {AdminApiResetSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetSessions(requestParameters: AdminApiResetSessionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminuserssessionResetSessionsResponse>> {
            const adminuserssessionResetSessionsRequest: AdminuserssessionResetSessionsRequest = {
                mobile_only: requestParameters.mobile_only,
                user_id: requestParameters.user_id,
                web_only: requestParameters.web_only
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetSessions(requestParameters.token, requestParameters.userId, adminuserssessionResetSessionsRequest, requestParameters.mobileOnly, requestParameters.webOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restrict an app for installation on a workspace.
         * @param {AdminApiRestrictAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restrictApp(requestParameters: AdminApiRestrictAppRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminappsRestrictAppResponse>> {
            const adminappsRestrictAppRequest: AdminappsRestrictAppRequest = {
                app_id: requestParameters.app_id,
                request_id: requestParameters.request_id,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.restrictApp(requestParameters.token, requestParameters.appId, requestParameters.requestId, requestParameters.teamId, adminappsRestrictAppRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {AdminApiSearchChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChannels(requestParameters: AdminApiSearchChannelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSearchChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChannels(requestParameters.token, requestParameters.teamIds, requestParameters.query, requestParameters.limit, requestParameters.cursor, requestParameters.searchChannelTypes, requestParameters.sort, requestParameters.sortDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set an existing guest, regular user, or owner to be an admin user.
         * @param {AdminApiSetAdminUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAdminUser(requestParameters: AdminApiSetAdminUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersSetAdminUserResponse>> {
            const adminusersSetAdminUserRequest: AdminusersSetAdminUserRequest = {
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAdminUser(requestParameters.token, requestParameters.teamId, requestParameters.userId, adminusersSetAdminUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {AdminApiSetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConversationPrefs(requestParameters: AdminApiSetConversationPrefsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSetConversationPrefsResponse>> {
            const adminconversationsSetConversationPrefsRequest: AdminconversationsSetConversationPrefsRequest = {
                channel_id: requestParameters.channel_id,
                prefs: requestParameters.prefs
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConversationPrefs(requestParameters.token, requestParameters.channelId, requestParameters.prefs, adminconversationsSetConversationPrefsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the default channels of a workspace.
         * @param {AdminApiSetDefaultChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultChannels(requestParameters: AdminApiSetDefaultChannelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsSetDefaultChannelsResponse>> {
            const adminteamssettingsSetDefaultChannelsRequest: AdminteamssettingsSetDefaultChannelsRequest = {
                channel_ids: requestParameters.channel_ids,
                team_id: requestParameters.team_id,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultChannels(requestParameters.channelIds, requestParameters.teamId, requestParameters.token, adminteamssettingsSetDefaultChannelsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the description of a given workspace.
         * @param {AdminApiSetDescriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDescription(requestParameters: AdminApiSetDescriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsSetDescriptionResponse>> {
            const adminteamssettingsSetDescriptionRequest: AdminteamssettingsSetDescriptionRequest = {
                description: requestParameters.description,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDescription(requestParameters.token, requestParameters.description, requestParameters.teamId, adminteamssettingsSetDescriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An API method that allows admins to set the discoverability of a given workspace
         * @param {AdminApiSetDiscoverabilityOfWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDiscoverabilityOfWorkspace(requestParameters: AdminApiSetDiscoverabilityOfWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsSetDiscoverabilityOfWorkspaceResponse>> {
            const adminteamssettingsSetDiscoverabilityOfWorkspaceRequest: AdminteamssettingsSetDiscoverabilityOfWorkspaceRequest = {
                discoverability: requestParameters.discoverability,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDiscoverabilityOfWorkspace(requestParameters.token, requestParameters.discoverability, requestParameters.teamId, adminteamssettingsSetDiscoverabilityOfWorkspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set an expiration for a guest user
         * @param {AdminApiSetExpirationGuestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExpirationGuest(requestParameters: AdminApiSetExpirationGuestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersSetExpirationGuestResponse>> {
            const adminusersSetExpirationGuestRequest: AdminusersSetExpirationGuestRequest = {
                expiration_ts: requestParameters.expiration_ts,
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExpirationGuest(requestParameters.token, requestParameters.expirationTs, requestParameters.teamId, requestParameters.userId, adminusersSetExpirationGuestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets the icon of a workspace.
         * @param {AdminApiSetIconRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setIcon(requestParameters: AdminApiSetIconRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsSetIconResponse>> {
            const adminteamssettingsSetIconRequest: AdminteamssettingsSetIconRequest = {
                image_url: requestParameters.image_url,
                team_id: requestParameters.team_id,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setIcon(requestParameters.imageUrl, requestParameters.teamId, requestParameters.token, adminteamssettingsSetIconRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the name of a given workspace.
         * @param {AdminApiSetNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setName(requestParameters: AdminApiSetNameRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminteamssettingsSetNameResponse>> {
            const adminteamssettingsSetNameRequest: AdminteamssettingsSetNameRequest = {
                name: requestParameters.name,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setName(requestParameters.token, requestParameters.name, requestParameters.teamId, adminteamssettingsSetNameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set an existing guest user, admin user, or owner to be a regular user.
         * @param {AdminApiSetRegularUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRegularUser(requestParameters: AdminApiSetRegularUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersSetRegularUserResponse>> {
            const adminusersSetRegularUserRequest: AdminusersSetRegularUserRequest = {
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRegularUser(requestParameters.token, requestParameters.teamId, requestParameters.userId, adminusersSetRegularUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {AdminApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTeamsWorkspaceConnection(requestParameters: AdminApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSetTeamsWorkspaceConnectionResponse>> {
            const adminconversationsSetTeamsWorkspaceConnectionRequest: AdminconversationsSetTeamsWorkspaceConnectionRequest = {
                channel_id: requestParameters.channel_id,
                org_channel: requestParameters.org_channel,
                target_team_ids: requestParameters.target_team_ids,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTeamsWorkspaceConnection(requestParameters.token, requestParameters.channelId, adminconversationsSetTeamsWorkspaceConnectionRequest, requestParameters.orgChannel, requestParameters.targetTeamIds, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set an existing guest, regular user, or admin user to be a workspace owner.
         * @param {AdminApiSetWorkspaceOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceOwner(requestParameters: AdminApiSetWorkspaceOwnerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminusersSetWorkspaceOwnerResponse>> {
            const adminusersSetWorkspaceOwnerRequest: AdminusersSetWorkspaceOwnerRequest = {
                team_id: requestParameters.team_id,
                user_id: requestParameters.user_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceOwner(requestParameters.token, requestParameters.teamId, requestParameters.userId, adminusersSetWorkspaceOwnerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unarchive a public or private channel.
         * @param {AdminApiUnarchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveChannel(requestParameters: AdminApiUnarchiveChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsUnarchiveChannelResponse>> {
            const adminconversationsUnarchiveChannelRequest: AdminconversationsUnarchiveChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveChannel(requestParameters.token, requestParameters.channelId, adminconversationsUnarchiveChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Add one or more default channels to an IDP group.
         * @param {AdminApiAddDefaultChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDefaultChannels(requestParameters: AdminApiAddDefaultChannelsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusergroupsAddDefaultChannelsResponse> {
            return localVarFp.addDefaultChannels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an emoji.
         * @param {AdminApiAddEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmoji(requestParameters: AdminApiAddEmojiRequest, options?: AxiosRequestConfig): AxiosPromise<AdminemojiAddEmojiResponse> {
            return localVarFp.addEmoji(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an allowlist of IDP groups for accessing a channel
         * @param {AdminApiAddGroupIdpGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupIdpGroups(requestParameters: AdminApiAddGroupIdpGroupsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsrestrictAccessAddGroupIdpGroupsResponse> {
            return localVarFp.addGroupIdpGroups(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an Enterprise user to a workspace.
         * @param {AdminApiAddWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser(requestParameters: AdminApiAddWorkspaceUserRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersAddWorkspaceUserResponse> {
            return localVarFp.addWorkspaceUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an emoji alias.
         * @param {AdminApiAliasAddRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aliasAdd(requestParameters: AdminApiAliasAddRequest, options?: AxiosRequestConfig): AxiosPromise<AdminemojiAliasAddResponse> {
            return localVarFp.aliasAdd(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve an app for installation on a workspace.
         * @param {AdminApiApproveAppInstallationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAppInstallation(requestParameters: AdminApiApproveAppInstallationRequest, options?: AxiosRequestConfig): AxiosPromise<AdminappsApproveAppInstallationResponse> {
            return localVarFp.approveAppInstallation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve a workspace invite request.
         * @param {AdminApiApproveRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveRequest(requestParameters: AdminApiApproveRequestRequest, options?: AxiosRequestConfig): AxiosPromise<AdmininviteRequestsApproveRequestResponse> {
            return localVarFp.approveRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive a public or private channel.
         * @param {AdminApiArchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChannel(requestParameters: AdminApiArchiveChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsArchiveChannelResponse> {
            return localVarFp.archiveChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Associate one or more default workspaces with an organization-wide IDP group.
         * @param {AdminApiAssociateDefaultWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateDefaultWorkspaces(requestParameters: AdminApiAssociateDefaultWorkspacesRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusergroupsAssociateDefaultWorkspacesResponse> {
            return localVarFp.associateDefaultWorkspaces(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert a public channel to a private channel.
         * @param {AdminApiConvertToPrivateChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPrivateChannel(requestParameters: AdminApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsConvertToPrivateChannelResponse> {
            return localVarFp.convertToPrivateChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {AdminApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelBasedConversation(requestParameters: AdminApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsCreateChannelBasedConversationResponse> {
            return localVarFp.createChannelBasedConversation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Enterprise team.
         * @param {AdminApiCreateEnterpriseTeamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnterpriseTeam(requestParameters: AdminApiCreateEnterpriseTeamRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamsCreateEnterpriseTeamResponse> {
            return localVarFp.createEnterpriseTeam(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public or private channel.
         * @param {AdminApiDeleteChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(requestParameters: AdminApiDeleteChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsDeleteChannelResponse> {
            return localVarFp.deleteChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deny a workspace invite request.
         * @param {AdminApiDenyRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyRequest(requestParameters: AdminApiDenyRequestRequest, options?: AxiosRequestConfig): AxiosPromise<AdmininviteRequestsDenyRequestResponse> {
            return localVarFp.denyRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {AdminApiDisconnectSharedChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSharedChannel(requestParameters: AdminApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsDisconnectSharedChannelResponse> {
            return localVarFp.disconnectSharedChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the admins on a given workspace.
         * @param {AdminApiGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(requestParameters: AdminApiGetAllRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamsadminsGetAllResponse> {
            return localVarFp.getAll(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {AdminApiGetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationPrefs(requestParameters: AdminApiGetConversationPrefsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsGetConversationPrefsResponse> {
            return localVarFp.getConversationPrefs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about settings in a workspace
         * @param {AdminApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(requestParameters: AdminApiGetInfoRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsGetInfoResponse> {
            return localVarFp.getInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List restricted apps for an org or workspace.
         * @param {AdminApiGetListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(requestParameters: AdminApiGetListRequest, options?: AxiosRequestConfig): AxiosPromise<AdminappsrestrictedGetListResponse> {
            return localVarFp.getList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {AdminApiGetTeamsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsList(requestParameters: AdminApiGetTeamsListRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsGetTeamsListResponse> {
            return localVarFp.getTeamsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidate a single session for a user by session_id
         * @param {AdminApiInvalidateSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateSession(requestParameters: AdminApiInvalidateSessionRequest, options?: AxiosRequestConfig): AxiosPromise<AdminuserssessionInvalidateSessionResponse> {
            return localVarFp.invalidateSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to a public or private channel.
         * @param {AdminApiInviteUserToChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToChannel(requestParameters: AdminApiInviteUserToChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsInviteUserToChannelResponse> {
            return localVarFp.inviteUserToChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to a workspace.
         * @param {AdminApiInviteUserToWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToWorkspace(requestParameters: AdminApiInviteUserToWorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersInviteUserToWorkspaceResponse> {
            return localVarFp.inviteUserToWorkspace(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List approved apps for an org or workspace.
         * @param {AdminApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: AdminApiListRequest, options?: AxiosRequestConfig): AxiosPromise<AdminappsapprovedListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all teams on an Enterprise organization
         * @param {AdminApiListAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAll(requestParameters: AdminApiListAllRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamsListAllResponse> {
            return localVarFp.listAll(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the channels linked to an org-level IDP group (user group).
         * @param {AdminApiListChannelsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChannelsGet(requestParameters: AdminApiListChannelsGetRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusergroupsListChannelsGetResponse> {
            return localVarFp.listChannelsGet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List emoji for an Enterprise Grid organization.
         * @param {AdminApiListEnterpriseEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnterpriseEmoji(requestParameters: AdminApiListEnterpriseEmojiRequest, options?: AxiosRequestConfig): AxiosPromise<AdminemojiListEnterpriseEmojiResponse> {
            return localVarFp.listEnterpriseEmoji(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all IDP Groups linked to a channel
         * @param {AdminApiListGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(requestParameters: AdminApiListGroupsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsrestrictAccessListGroupsResponse> {
            return localVarFp.listGroups(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
         * @param {AdminApiListOriginalConnectedChannelInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOriginalConnectedChannelInfo(requestParameters: AdminApiListOriginalConnectedChannelInfoRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsekmListOriginalConnectedChannelInfoResponse> {
            return localVarFp.listOriginalConnectedChannelInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the owners on a given workspace.
         * @param {AdminApiListOwnersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwners(requestParameters: AdminApiListOwnersRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamsownersListOwnersResponse> {
            return localVarFp.listOwners(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all pending workspace invite requests.
         * @param {AdminApiListPendingWorkspaceInviteRequestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPendingWorkspaceInviteRequests(requestParameters: AdminApiListPendingWorkspaceInviteRequestsRequest, options?: AxiosRequestConfig): AxiosPromise<AdmininviteRequestsListPendingWorkspaceInviteRequestsResponse> {
            return localVarFp.listPendingWorkspaceInviteRequests(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List users on a workspace
         * @param {AdminApiListWorkspaceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers(requestParameters: AdminApiListWorkspaceUsersRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersListWorkspaceUsersResponse> {
            return localVarFp.listWorkspaceUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List app requests for a team/workspace.
         * @param {AdminApiList0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_1(requestParameters: AdminApiList0Request, options?: AxiosRequestConfig): AxiosPromise<AdminappsrequestsListResponse> {
            return localVarFp.list_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all approved workspace invite requests.
         * @param {AdminApiList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_2(requestParameters: AdminApiList1Request, options?: AxiosRequestConfig): AxiosPromise<AdmininviteRequestsapprovedListResponse> {
            return localVarFp.list_2(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all denied workspace invite requests.
         * @param {AdminApiList2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list_3(requestParameters: AdminApiList2Request, options?: AxiosRequestConfig): AxiosPromise<AdmininviteRequestsdeniedListResponse> {
            return localVarFp.list_3(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove one or more default channels from an org-level IDP group (user group).
         * @param {AdminApiRemoveChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeChannels(requestParameters: AdminApiRemoveChannelsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusergroupsRemoveChannelsResponse> {
            return localVarFp.removeChannels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an emoji across an Enterprise Grid organization
         * @param {AdminApiRemoveEnterpriseEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEnterpriseEmoji(requestParameters: AdminApiRemoveEnterpriseEmojiRequest, options?: AxiosRequestConfig): AxiosPromise<AdminemojiRemoveEnterpriseEmojiResponse> {
            return localVarFp.removeEnterpriseEmoji(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a linked IDP group linked from a private channel
         * @param {AdminApiRemoveIdpGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeIdpGroup(requestParameters: AdminApiRemoveIdpGroupRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsrestrictAccessRemoveIdpGroupResponse> {
            return localVarFp.removeIdpGroup(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user from a workspace.
         * @param {AdminApiRemoveUserFromWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromWorkspace(requestParameters: AdminApiRemoveUserFromWorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersRemoveUserFromWorkspaceResponse> {
            return localVarFp.removeUserFromWorkspace(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename a public or private channel.
         * @param {AdminApiRenameChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameChannel(requestParameters: AdminApiRenameChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsRenameChannelResponse> {
            return localVarFp.renameChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename an emoji.
         * @param {AdminApiRenameEmojiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameEmoji(requestParameters: AdminApiRenameEmojiRequest, options?: AxiosRequestConfig): AxiosPromise<AdminemojiRenameEmojiResponse> {
            return localVarFp.renameEmoji(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Wipes all valid sessions on all devices for a given user
         * @param {AdminApiResetSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetSessions(requestParameters: AdminApiResetSessionsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminuserssessionResetSessionsResponse> {
            return localVarFp.resetSessions(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Restrict an app for installation on a workspace.
         * @param {AdminApiRestrictAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restrictApp(requestParameters: AdminApiRestrictAppRequest, options?: AxiosRequestConfig): AxiosPromise<AdminappsRestrictAppResponse> {
            return localVarFp.restrictApp(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {AdminApiSearchChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChannels(requestParameters: AdminApiSearchChannelsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSearchChannelsResponse> {
            return localVarFp.searchChannels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an existing guest, regular user, or owner to be an admin user.
         * @param {AdminApiSetAdminUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAdminUser(requestParameters: AdminApiSetAdminUserRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersSetAdminUserResponse> {
            return localVarFp.setAdminUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {AdminApiSetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConversationPrefs(requestParameters: AdminApiSetConversationPrefsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSetConversationPrefsResponse> {
            return localVarFp.setConversationPrefs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the default channels of a workspace.
         * @param {AdminApiSetDefaultChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultChannels(requestParameters: AdminApiSetDefaultChannelsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsSetDefaultChannelsResponse> {
            return localVarFp.setDefaultChannels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the description of a given workspace.
         * @param {AdminApiSetDescriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDescription(requestParameters: AdminApiSetDescriptionRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsSetDescriptionResponse> {
            return localVarFp.setDescription(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * An API method that allows admins to set the discoverability of a given workspace
         * @param {AdminApiSetDiscoverabilityOfWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiscoverabilityOfWorkspace(requestParameters: AdminApiSetDiscoverabilityOfWorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsSetDiscoverabilityOfWorkspaceResponse> {
            return localVarFp.setDiscoverabilityOfWorkspace(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an expiration for a guest user
         * @param {AdminApiSetExpirationGuestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExpirationGuest(requestParameters: AdminApiSetExpirationGuestRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersSetExpirationGuestResponse> {
            return localVarFp.setExpirationGuest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the icon of a workspace.
         * @param {AdminApiSetIconRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIcon(requestParameters: AdminApiSetIconRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsSetIconResponse> {
            return localVarFp.setIcon(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the name of a given workspace.
         * @param {AdminApiSetNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName(requestParameters: AdminApiSetNameRequest, options?: AxiosRequestConfig): AxiosPromise<AdminteamssettingsSetNameResponse> {
            return localVarFp.setName(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an existing guest user, admin user, or owner to be a regular user.
         * @param {AdminApiSetRegularUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRegularUser(requestParameters: AdminApiSetRegularUserRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersSetRegularUserResponse> {
            return localVarFp.setRegularUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {AdminApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamsWorkspaceConnection(requestParameters: AdminApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSetTeamsWorkspaceConnectionResponse> {
            return localVarFp.setTeamsWorkspaceConnection(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an existing guest, regular user, or admin user to be a workspace owner.
         * @param {AdminApiSetWorkspaceOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceOwner(requestParameters: AdminApiSetWorkspaceOwnerRequest, options?: AxiosRequestConfig): AxiosPromise<AdminusersSetWorkspaceOwnerResponse> {
            return localVarFp.setWorkspaceOwner(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Unarchive a public or private channel.
         * @param {AdminApiUnarchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveChannel(requestParameters: AdminApiUnarchiveChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsUnarchiveChannelResponse> {
            return localVarFp.unarchiveChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addDefaultChannels operation in AdminApi.
 * @export
 * @interface AdminApiAddDefaultChannelsRequest
 */
export type AdminApiAddDefaultChannelsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.usergroups:write`
    * @type {string}
    * @memberof AdminApiAddDefaultChannels
    */
    readonly token: string
    
    /**
    * Comma separated string of channel IDs.
    * @type {string}
    * @memberof AdminApiAddDefaultChannels
    */
    readonly channelIds: string
    
    /**
    * ID of the IDP group to add default channels for.
    * @type {string}
    * @memberof AdminApiAddDefaultChannels
    */
    readonly usergroupId: string
    
    /**
    * The workspace to add default channels in.
    * @type {string}
    * @memberof AdminApiAddDefaultChannels
    */
    readonly teamId?: string
    
} & AdminusergroupsAddDefaultChannelsRequest

/**
 * Request parameters for addEmoji operation in AdminApi.
 * @export
 * @interface AdminApiAddEmojiRequest
 */
export type AdminApiAddEmojiRequest = {
    
    /**
    * The name of the emoji to be removed. Colons (`:myemoji:`) around the value are not required, although they may be included.
    * @type {string}
    * @memberof AdminApiAddEmoji
    */
    readonly name: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiAddEmoji
    */
    readonly token: string
    
    /**
    * The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best.
    * @type {string}
    * @memberof AdminApiAddEmoji
    */
    readonly url: string
    
} & AdminemojiAddEmojiRequest

/**
 * Request parameters for addGroupIdpGroups operation in AdminApi.
 * @export
 * @interface AdminApiAddGroupIdpGroupsRequest
 */
export type AdminApiAddGroupIdpGroupsRequest = {
    
    /**
    * The channel to link this group to.
    * @type {string}
    * @memberof AdminApiAddGroupIdpGroups
    */
    readonly channelId: string
    
    /**
    * The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel.
    * @type {string}
    * @memberof AdminApiAddGroupIdpGroups
    */
    readonly groupId: string
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiAddGroupIdpGroups
    */
    readonly token: string
    
    /**
    * The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
    * @type {string}
    * @memberof AdminApiAddGroupIdpGroups
    */
    readonly teamId?: string
    
} & AdminconversationsrestrictAccessAddGroupIdpGroupsRequest

/**
 * Request parameters for addWorkspaceUser operation in AdminApi.
 * @export
 * @interface AdminApiAddWorkspaceUserRequest
 */
export type AdminApiAddWorkspaceUserRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly teamId: string
    
    /**
    * The ID of the user to add to the workspace.
    * @type {string}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly userId: string
    
    /**
    * Comma separated values of channel IDs to add user in the new workspace.
    * @type {string}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly channelIds?: string
    
    /**
    * True if user should be added to the workspace as a guest.
    * @type {boolean}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly isRestricted?: boolean
    
    /**
    * True if user should be added to the workspace as a single-channel guest.
    * @type {boolean}
    * @memberof AdminApiAddWorkspaceUser
    */
    readonly isUltraRestricted?: boolean
    
} & AdminusersAddWorkspaceUserRequest

/**
 * Request parameters for aliasAdd operation in AdminApi.
 * @export
 * @interface AdminApiAliasAddRequest
 */
export type AdminApiAliasAddRequest = {
    
    /**
    * The alias of the emoji.
    * @type {string}
    * @memberof AdminApiAliasAdd
    */
    readonly aliasFor: string
    
    /**
    * The name of the emoji to be aliased. Colons (`:myemoji:`) around the value are not required, although they may be included.
    * @type {string}
    * @memberof AdminApiAliasAdd
    */
    readonly name: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiAliasAdd
    */
    readonly token: string
    
} & AdminemojiAliasAddRequest

/**
 * Request parameters for approveAppInstallation operation in AdminApi.
 * @export
 * @interface AdminApiApproveAppInstallationRequest
 */
export type AdminApiApproveAppInstallationRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.apps:write`
    * @type {string}
    * @memberof AdminApiApproveAppInstallation
    */
    readonly token: string
    
    /**
    * The id of the app to approve.
    * @type {string}
    * @memberof AdminApiApproveAppInstallation
    */
    readonly appId?: string
    
    /**
    * The id of the request to approve.
    * @type {string}
    * @memberof AdminApiApproveAppInstallation
    */
    readonly requestId?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiApproveAppInstallation
    */
    readonly teamId?: string
    
} & AdminappsApproveAppInstallationRequest

/**
 * Request parameters for approveRequest operation in AdminApi.
 * @export
 * @interface AdminApiApproveRequestRequest
 */
export type AdminApiApproveRequestRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.invites:write`
    * @type {string}
    * @memberof AdminApiApproveRequest
    */
    readonly token: string
    
} & AdmininviteRequestsApproveRequestRequest

/**
 * Request parameters for archiveChannel operation in AdminApi.
 * @export
 * @interface AdminApiArchiveChannelRequest
 */
export type AdminApiArchiveChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiArchiveChannel
    */
    readonly token: string
    
    /**
    * The channel to archive.
    * @type {string}
    * @memberof AdminApiArchiveChannel
    */
    readonly channelId: string
    
} & AdminconversationsArchiveChannelRequest

/**
 * Request parameters for associateDefaultWorkspaces operation in AdminApi.
 * @export
 * @interface AdminApiAssociateDefaultWorkspacesRequest
 */
export type AdminApiAssociateDefaultWorkspacesRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiAssociateDefaultWorkspaces
    */
    readonly token: string
    
    /**
    * A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token.
    * @type {string}
    * @memberof AdminApiAssociateDefaultWorkspaces
    */
    readonly teamIds: string
    
    /**
    * An encoded usergroup (IDP Group) ID.
    * @type {string}
    * @memberof AdminApiAssociateDefaultWorkspaces
    */
    readonly usergroupId: string
    
    /**
    * When `true`, this method automatically creates new workspace accounts for the IDP group members.
    * @type {boolean}
    * @memberof AdminApiAssociateDefaultWorkspaces
    */
    readonly autoProvision?: boolean
    
} & AdminusergroupsAssociateDefaultWorkspacesRequest

/**
 * Request parameters for convertToPrivateChannel operation in AdminApi.
 * @export
 * @interface AdminApiConvertToPrivateChannelRequest
 */
export type AdminApiConvertToPrivateChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiConvertToPrivateChannel
    */
    readonly token: string
    
    /**
    * The channel to convert to private.
    * @type {string}
    * @memberof AdminApiConvertToPrivateChannel
    */
    readonly channelId: string
    
} & AdminconversationsConvertToPrivateChannelRequest

/**
 * Request parameters for createChannelBasedConversation operation in AdminApi.
 * @export
 * @interface AdminApiCreateChannelBasedConversationRequest
 */
export type AdminApiCreateChannelBasedConversationRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly token: string
    
    /**
    * When `true`, creates a private channel instead of a public channel
    * @type {boolean}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly isPrivate: boolean
    
    /**
    * Name of the public or private channel to create.
    * @type {string}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly name: string
    
    /**
    * Description of the public or private channel to create.
    * @type {string}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly description?: string
    
    /**
    * When `true`, the channel will be available org-wide. Note: if the channel is not `org_wide=true`, you must specify a `team_id` for this channel
    * @type {boolean}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly orgWide?: boolean
    
    /**
    * The workspace to create the channel in. Note: this argument is required unless you set `org_wide=true`.
    * @type {string}
    * @memberof AdminApiCreateChannelBasedConversation
    */
    readonly teamId?: string
    
} & AdminconversationsCreateChannelBasedConversationRequest

/**
 * Request parameters for createEnterpriseTeam operation in AdminApi.
 * @export
 * @interface AdminApiCreateEnterpriseTeamRequest
 */
export type AdminApiCreateEnterpriseTeamRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiCreateEnterpriseTeam
    */
    readonly token: string
    
    /**
    * Team domain (for example, slacksoftballteam).
    * @type {string}
    * @memberof AdminApiCreateEnterpriseTeam
    */
    readonly teamDomain: string
    
    /**
    * Team name (for example, Slack Softball Team).
    * @type {string}
    * @memberof AdminApiCreateEnterpriseTeam
    */
    readonly teamName: string
    
    /**
    * Description for the team.
    * @type {string}
    * @memberof AdminApiCreateEnterpriseTeam
    */
    readonly teamDescription?: string
    
    /**
    * Who can join the team. A team\\\'s discoverability can be `open`, `closed`, `invite_only`, or `unlisted`.
    * @type {string}
    * @memberof AdminApiCreateEnterpriseTeam
    */
    readonly teamDiscoverability?: string
    
} & AdminteamsCreateEnterpriseTeamRequest

/**
 * Request parameters for deleteChannel operation in AdminApi.
 * @export
 * @interface AdminApiDeleteChannelRequest
 */
export type AdminApiDeleteChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiDeleteChannel
    */
    readonly token: string
    
    /**
    * The channel to delete.
    * @type {string}
    * @memberof AdminApiDeleteChannel
    */
    readonly channelId: string
    
} & AdminconversationsDeleteChannelRequest

/**
 * Request parameters for denyRequest operation in AdminApi.
 * @export
 * @interface AdminApiDenyRequestRequest
 */
export type AdminApiDenyRequestRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.invites:write`
    * @type {string}
    * @memberof AdminApiDenyRequest
    */
    readonly token: string
    
} & AdmininviteRequestsApproveRequestRequest

/**
 * Request parameters for disconnectSharedChannel operation in AdminApi.
 * @export
 * @interface AdminApiDisconnectSharedChannelRequest
 */
export type AdminApiDisconnectSharedChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiDisconnectSharedChannel
    */
    readonly token: string
    
    /**
    * The channel to be disconnected from some workspaces.
    * @type {string}
    * @memberof AdminApiDisconnectSharedChannel
    */
    readonly channelId: string
    
    /**
    * The team to be removed from the channel. Currently only a single team id can be specified.
    * @type {string}
    * @memberof AdminApiDisconnectSharedChannel
    */
    readonly leavingTeamIds?: string
    
} & AdminconversationsDisconnectSharedChannelRequest

/**
 * Request parameters for getAll operation in AdminApi.
 * @export
 * @interface AdminApiGetAllRequest
 */
export type AdminApiGetAllRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:read`
    * @type {string}
    * @memberof AdminApiGetAll
    */
    readonly token: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiGetAll
    */
    readonly teamId: string
    
    /**
    * The maximum number of items to return.
    * @type {number}
    * @memberof AdminApiGetAll
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiGetAll
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for getConversationPrefs operation in AdminApi.
 * @export
 * @interface AdminApiGetConversationPrefsRequest
 */
export type AdminApiGetConversationPrefsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminApiGetConversationPrefs
    */
    readonly token: string
    
    /**
    * The channel to get preferences for.
    * @type {string}
    * @memberof AdminApiGetConversationPrefs
    */
    readonly channelId: string
    
}

/**
 * Request parameters for getInfo operation in AdminApi.
 * @export
 * @interface AdminApiGetInfoRequest
 */
export type AdminApiGetInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:read`
    * @type {string}
    * @memberof AdminApiGetInfo
    */
    readonly token: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiGetInfo
    */
    readonly teamId: string
    
}

/**
 * Request parameters for getList operation in AdminApi.
 * @export
 * @interface AdminApiGetListRequest
 */
export type AdminApiGetListRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.apps:read`
    * @type {string}
    * @memberof AdminApiGetList
    */
    readonly token: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiGetList
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminApiGetList
    */
    readonly cursor?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiGetList
    */
    readonly teamId?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiGetList
    */
    readonly enterpriseId?: string
    
}

/**
 * Request parameters for getTeamsList operation in AdminApi.
 * @export
 * @interface AdminApiGetTeamsListRequest
 */
export type AdminApiGetTeamsListRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminApiGetTeamsList
    */
    readonly token: string
    
    /**
    * The channel to determine connected workspaces within the organization for.
    * @type {string}
    * @memberof AdminApiGetTeamsList
    */
    readonly channelId: string
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminApiGetTeamsList
    */
    readonly cursor?: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiGetTeamsList
    */
    readonly limit?: number
    
}

/**
 * Request parameters for invalidateSession operation in AdminApi.
 * @export
 * @interface AdminApiInvalidateSessionRequest
 */
export type AdminApiInvalidateSessionRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiInvalidateSession
    */
    readonly token: string
    
    /**
    * 
    * @type {number}
    * @memberof AdminApiInvalidateSession
    */
    readonly sessionId: number
    
    /**
    * ID of the team that the session belongs to
    * @type {string}
    * @memberof AdminApiInvalidateSession
    */
    readonly teamId: string
    
} & AdminuserssessionInvalidateSessionRequest

/**
 * Request parameters for inviteUserToChannel operation in AdminApi.
 * @export
 * @interface AdminApiInviteUserToChannelRequest
 */
export type AdminApiInviteUserToChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiInviteUserToChannel
    */
    readonly token: string
    
    /**
    * The channel that the users will be invited to.
    * @type {string}
    * @memberof AdminApiInviteUserToChannel
    */
    readonly channelId: string
    
    /**
    * The users to invite.
    * @type {string}
    * @memberof AdminApiInviteUserToChannel
    */
    readonly userIds: string
    
} & AdminconversationsInviteUserToChannelRequest

/**
 * Request parameters for inviteUserToWorkspace operation in AdminApi.
 * @export
 * @interface AdminApiInviteUserToWorkspaceRequest
 */
export type AdminApiInviteUserToWorkspaceRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly token: string
    
    /**
    * A comma-separated list of `channel_id`s for this user to join. At least one channel is required.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly channelIds: string
    
    /**
    * The email address of the person to invite.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly email: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly teamId: string
    
    /**
    * An optional message to send to the user in the invite email.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly customMessage?: string
    
    /**
    * Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly guestExpirationTs?: string
    
    /**
    * Is this user a multi-channel guest user? (default: false)
    * @type {boolean}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly isRestricted?: boolean
    
    /**
    * Is this user a single channel guest user? (default: false)
    * @type {boolean}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly isUltraRestricted?: boolean
    
    /**
    * Full name of the user.
    * @type {string}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly realName?: string
    
    /**
    * Allow this invite to be resent in the future if a user has not signed up yet. (default: false)
    * @type {boolean}
    * @memberof AdminApiInviteUserToWorkspace
    */
    readonly resend?: boolean
    
} & AdminusersInviteUserToWorkspaceRequest

/**
 * Request parameters for list operation in AdminApi.
 * @export
 * @interface AdminApiListRequest
 */
export type AdminApiListRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.apps:read`
    * @type {string}
    * @memberof AdminApiList
    */
    readonly token: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiList
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminApiList
    */
    readonly cursor?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiList
    */
    readonly teamId?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiList
    */
    readonly enterpriseId?: string
    
}

/**
 * Request parameters for listAll operation in AdminApi.
 * @export
 * @interface AdminApiListAllRequest
 */
export type AdminApiListAllRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:read`
    * @type {string}
    * @memberof AdminApiListAll
    */
    readonly token: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 100 both inclusive.
    * @type {number}
    * @memberof AdminApiListAll
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiListAll
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for listChannelsGet operation in AdminApi.
 * @export
 * @interface AdminApiListChannelsGetRequest
 */
export type AdminApiListChannelsGetRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.usergroups:read`
    * @type {string}
    * @memberof AdminApiListChannelsGet
    */
    readonly token: string
    
    /**
    * ID of the IDP group to list default channels for.
    * @type {string}
    * @memberof AdminApiListChannelsGet
    */
    readonly usergroupId: string
    
    /**
    * ID of the the workspace.
    * @type {string}
    * @memberof AdminApiListChannelsGet
    */
    readonly teamId?: string
    
    /**
    * Flag to include or exclude the count of members per channel.
    * @type {boolean}
    * @memberof AdminApiListChannelsGet
    */
    readonly includeNumMembers?: boolean
    
}

/**
 * Request parameters for listEnterpriseEmoji operation in AdminApi.
 * @export
 * @interface AdminApiListEnterpriseEmojiRequest
 */
export type AdminApiListEnterpriseEmojiRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:read`
    * @type {string}
    * @memberof AdminApiListEnterpriseEmoji
    */
    readonly token: string
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminApiListEnterpriseEmoji
    */
    readonly cursor?: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiListEnterpriseEmoji
    */
    readonly limit?: number
    
}

/**
 * Request parameters for listGroups operation in AdminApi.
 * @export
 * @interface AdminApiListGroupsRequest
 */
export type AdminApiListGroupsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminApiListGroups
    */
    readonly token: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiListGroups
    */
    readonly channelId: string
    
    /**
    * The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
    * @type {string}
    * @memberof AdminApiListGroups
    */
    readonly teamId?: string
    
}

/**
 * Request parameters for listOriginalConnectedChannelInfo operation in AdminApi.
 * @export
 * @interface AdminApiListOriginalConnectedChannelInfoRequest
 */
export type AdminApiListOriginalConnectedChannelInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminApiListOriginalConnectedChannelInfo
    */
    readonly token: string
    
    /**
    * A comma-separated list of channels to filter to.
    * @type {string}
    * @memberof AdminApiListOriginalConnectedChannelInfo
    */
    readonly channelIds?: string
    
    /**
    * A comma-separated list of the workspaces to which the channels you would like returned belong.
    * @type {string}
    * @memberof AdminApiListOriginalConnectedChannelInfo
    */
    readonly teamIds?: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiListOriginalConnectedChannelInfo
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiListOriginalConnectedChannelInfo
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for listOwners operation in AdminApi.
 * @export
 * @interface AdminApiListOwnersRequest
 */
export type AdminApiListOwnersRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:read`
    * @type {string}
    * @memberof AdminApiListOwners
    */
    readonly token: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiListOwners
    */
    readonly teamId: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiListOwners
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiListOwners
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for listPendingWorkspaceInviteRequests operation in AdminApi.
 * @export
 * @interface AdminApiListPendingWorkspaceInviteRequestsRequest
 */
export type AdminApiListPendingWorkspaceInviteRequestsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.invites:read`
    * @type {string}
    * @memberof AdminApiListPendingWorkspaceInviteRequests
    */
    readonly token: string
    
    /**
    * ID for the workspace where the invite requests were made.
    * @type {string}
    * @memberof AdminApiListPendingWorkspaceInviteRequests
    */
    readonly teamId?: string
    
    /**
    * Value of the `next_cursor` field sent as part of the previous API response
    * @type {string}
    * @memberof AdminApiListPendingWorkspaceInviteRequests
    */
    readonly cursor?: string
    
    /**
    * The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
    * @type {number}
    * @memberof AdminApiListPendingWorkspaceInviteRequests
    */
    readonly limit?: number
    
}

/**
 * Request parameters for listWorkspaceUsers operation in AdminApi.
 * @export
 * @interface AdminApiListWorkspaceUsersRequest
 */
export type AdminApiListWorkspaceUsersRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:read`
    * @type {string}
    * @memberof AdminApiListWorkspaceUsers
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiListWorkspaceUsers
    */
    readonly teamId: string
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiListWorkspaceUsers
    */
    readonly cursor?: string
    
    /**
    * Limit for how many users to be retrieved per page
    * @type {number}
    * @memberof AdminApiListWorkspaceUsers
    */
    readonly limit?: number
    
}

/**
 * Request parameters for list_1 operation in AdminApi.
 * @export
 * @interface AdminApiList0Request
 */
export type AdminApiList0Request = {
    
    /**
    * Authentication token. Requires scope: `admin.apps:read`
    * @type {string}
    * @memberof AdminApiList0
    */
    readonly token: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminApiList0
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminApiList0
    */
    readonly cursor?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiList0
    */
    readonly teamId?: string
    
}

/**
 * Request parameters for list_2 operation in AdminApi.
 * @export
 * @interface AdminApiList1Request
 */
export type AdminApiList1Request = {
    
    /**
    * Authentication token. Requires scope: `admin.invites:read`
    * @type {string}
    * @memberof AdminApiList1
    */
    readonly token: string
    
    /**
    * ID for the workspace where the invite requests were made.
    * @type {string}
    * @memberof AdminApiList1
    */
    readonly teamId?: string
    
    /**
    * Value of the `next_cursor` field sent as part of the previous API response
    * @type {string}
    * @memberof AdminApiList1
    */
    readonly cursor?: string
    
    /**
    * The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive
    * @type {number}
    * @memberof AdminApiList1
    */
    readonly limit?: number
    
}

/**
 * Request parameters for list_3 operation in AdminApi.
 * @export
 * @interface AdminApiList2Request
 */
export type AdminApiList2Request = {
    
    /**
    * Authentication token. Requires scope: `admin.invites:read`
    * @type {string}
    * @memberof AdminApiList2
    */
    readonly token: string
    
    /**
    * ID for the workspace where the invite requests were made.
    * @type {string}
    * @memberof AdminApiList2
    */
    readonly teamId?: string
    
    /**
    * Value of the `next_cursor` field sent as part of the previous api response
    * @type {string}
    * @memberof AdminApiList2
    */
    readonly cursor?: string
    
    /**
    * The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive
    * @type {number}
    * @memberof AdminApiList2
    */
    readonly limit?: number
    
}

/**
 * Request parameters for removeChannels operation in AdminApi.
 * @export
 * @interface AdminApiRemoveChannelsRequest
 */
export type AdminApiRemoveChannelsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.usergroups:write`
    * @type {string}
    * @memberof AdminApiRemoveChannels
    */
    readonly token: string
    
    /**
    * Comma-separated string of channel IDs
    * @type {string}
    * @memberof AdminApiRemoveChannels
    */
    readonly channelIds: string
    
    /**
    * ID of the IDP Group
    * @type {string}
    * @memberof AdminApiRemoveChannels
    */
    readonly usergroupId: string
    
} & AdminusergroupsRemoveChannelsRequest

/**
 * Request parameters for removeEnterpriseEmoji operation in AdminApi.
 * @export
 * @interface AdminApiRemoveEnterpriseEmojiRequest
 */
export type AdminApiRemoveEnterpriseEmojiRequest = {
    
    /**
    * The name of the emoji to be removed. Colons (`:myemoji:`) around the value are not required, although they may be included.
    * @type {string}
    * @memberof AdminApiRemoveEnterpriseEmoji
    */
    readonly name: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiRemoveEnterpriseEmoji
    */
    readonly token: string
    
} & AdminemojiRemoveEnterpriseEmojiRequest

/**
 * Request parameters for removeIdpGroup operation in AdminApi.
 * @export
 * @interface AdminApiRemoveIdpGroupRequest
 */
export type AdminApiRemoveIdpGroupRequest = {
    
    /**
    * The channel to remove the linked group from.
    * @type {string}
    * @memberof AdminApiRemoveIdpGroup
    */
    readonly channelId: string
    
    /**
    * The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel.
    * @type {string}
    * @memberof AdminApiRemoveIdpGroup
    */
    readonly groupId: string
    
    /**
    * The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization.
    * @type {string}
    * @memberof AdminApiRemoveIdpGroup
    */
    readonly teamId: string
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiRemoveIdpGroup
    */
    readonly token: string
    
} & AdminconversationsrestrictAccessRemoveIdpGroupRequest

/**
 * Request parameters for removeUserFromWorkspace operation in AdminApi.
 * @export
 * @interface AdminApiRemoveUserFromWorkspaceRequest
 */
export type AdminApiRemoveUserFromWorkspaceRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiRemoveUserFromWorkspace
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiRemoveUserFromWorkspace
    */
    readonly teamId: string
    
    /**
    * The ID of the user to remove.
    * @type {string}
    * @memberof AdminApiRemoveUserFromWorkspace
    */
    readonly userId: string
    
} & AdminusersRemoveUserFromWorkspaceRequest

/**
 * Request parameters for renameChannel operation in AdminApi.
 * @export
 * @interface AdminApiRenameChannelRequest
 */
export type AdminApiRenameChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiRenameChannel
    */
    readonly token: string
    
    /**
    * The channel to rename.
    * @type {string}
    * @memberof AdminApiRenameChannel
    */
    readonly channelId: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiRenameChannel
    */
    readonly name: string
    
} & AdminconversationsRenameChannelRequest

/**
 * Request parameters for renameEmoji operation in AdminApi.
 * @export
 * @interface AdminApiRenameEmojiRequest
 */
export type AdminApiRenameEmojiRequest = {
    
    /**
    * The name of the emoji to be renamed. Colons (`:myemoji:`) around the value are not required, although they may be included.
    * @type {string}
    * @memberof AdminApiRenameEmoji
    */
    readonly name: string
    
    /**
    * The new name of the emoji.
    * @type {string}
    * @memberof AdminApiRenameEmoji
    */
    readonly newName: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiRenameEmoji
    */
    readonly token: string
    
} & AdminemojiRenameEmojiRequest

/**
 * Request parameters for resetSessions operation in AdminApi.
 * @export
 * @interface AdminApiResetSessionsRequest
 */
export type AdminApiResetSessionsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiResetSessions
    */
    readonly token: string
    
    /**
    * The ID of the user to wipe sessions for
    * @type {string}
    * @memberof AdminApiResetSessions
    */
    readonly userId: string
    
    /**
    * Only expire mobile sessions (default: false)
    * @type {boolean}
    * @memberof AdminApiResetSessions
    */
    readonly mobileOnly?: boolean
    
    /**
    * Only expire web sessions (default: false)
    * @type {boolean}
    * @memberof AdminApiResetSessions
    */
    readonly webOnly?: boolean
    
} & AdminuserssessionResetSessionsRequest

/**
 * Request parameters for restrictApp operation in AdminApi.
 * @export
 * @interface AdminApiRestrictAppRequest
 */
export type AdminApiRestrictAppRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.apps:write`
    * @type {string}
    * @memberof AdminApiRestrictApp
    */
    readonly token: string
    
    /**
    * The id of the app to restrict.
    * @type {string}
    * @memberof AdminApiRestrictApp
    */
    readonly appId?: string
    
    /**
    * The id of the request to restrict.
    * @type {string}
    * @memberof AdminApiRestrictApp
    */
    readonly requestId?: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminApiRestrictApp
    */
    readonly teamId?: string
    
} & AdminappsRestrictAppRequest

/**
 * Request parameters for searchChannels operation in AdminApi.
 * @export
 * @interface AdminApiSearchChannelsRequest
 */
export type AdminApiSearchChannelsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly token: string
    
    /**
    * Comma separated string of team IDs, signifying the workspaces to search through.
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly teamIds?: string
    
    /**
    * Name of the the channel to query by.
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly query?: string
    
    /**
    * Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
    * @type {number}
    * @memberof AdminApiSearchChannels
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly cursor?: string
    
    /**
    * The type of channel to include or exclude in the search. For example `private` will search private channels, while `private_exclude` will exclude them. For a full list of types, check the [Types section](https://slack.dev).
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly searchChannelTypes?: string
    
    /**
    * Possible values are `relevant` (search ranking based on what we think is closest), `name` (alphabetical), `member_count` (number of users in the channel), and `created` (date channel was created). You can optionally pair this with the `sort_dir` arg to change how it is sorted 
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly sort?: string
    
    /**
    * Sort direction. Possible values are `asc` for ascending order like (1, 2, 3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b, a)
    * @type {string}
    * @memberof AdminApiSearchChannels
    */
    readonly sortDir?: string
    
}

/**
 * Request parameters for setAdminUser operation in AdminApi.
 * @export
 * @interface AdminApiSetAdminUserRequest
 */
export type AdminApiSetAdminUserRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiSetAdminUser
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiSetAdminUser
    */
    readonly teamId: string
    
    /**
    * The ID of the user to designate as an admin.
    * @type {string}
    * @memberof AdminApiSetAdminUser
    */
    readonly userId: string
    
} & AdminusersSetAdminUserRequest

/**
 * Request parameters for setConversationPrefs operation in AdminApi.
 * @export
 * @interface AdminApiSetConversationPrefsRequest
 */
export type AdminApiSetConversationPrefsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiSetConversationPrefs
    */
    readonly token: string
    
    /**
    * The channel to set the prefs for
    * @type {string}
    * @memberof AdminApiSetConversationPrefs
    */
    readonly channelId: string
    
    /**
    * The prefs for this channel in a stringified JSON format.
    * @type {string}
    * @memberof AdminApiSetConversationPrefs
    */
    readonly prefs: string
    
} & AdminconversationsSetConversationPrefsRequest

/**
 * Request parameters for setDefaultChannels operation in AdminApi.
 * @export
 * @interface AdminApiSetDefaultChannelsRequest
 */
export type AdminApiSetDefaultChannelsRequest = {
    
    /**
    * An array of channel IDs.
    * @type {string}
    * @memberof AdminApiSetDefaultChannels
    */
    readonly channelIds: string
    
    /**
    * ID for the workspace to set the default channel for.
    * @type {string}
    * @memberof AdminApiSetDefaultChannels
    */
    readonly teamId: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiSetDefaultChannels
    */
    readonly token: string
    
} & AdminteamssettingsSetDefaultChannelsRequest

/**
 * Request parameters for setDescription operation in AdminApi.
 * @export
 * @interface AdminApiSetDescriptionRequest
 */
export type AdminApiSetDescriptionRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiSetDescription
    */
    readonly token: string
    
    /**
    * The new description for the workspace.
    * @type {string}
    * @memberof AdminApiSetDescription
    */
    readonly description: string
    
    /**
    * ID for the workspace to set the description for.
    * @type {string}
    * @memberof AdminApiSetDescription
    */
    readonly teamId: string
    
} & AdminteamssettingsSetDescriptionRequest

/**
 * Request parameters for setDiscoverabilityOfWorkspace operation in AdminApi.
 * @export
 * @interface AdminApiSetDiscoverabilityOfWorkspaceRequest
 */
export type AdminApiSetDiscoverabilityOfWorkspaceRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiSetDiscoverabilityOfWorkspace
    */
    readonly token: string
    
    /**
    * This workspace\\\'s discovery setting. It must be set to one of `open`, `invite_only`, `closed`, or `unlisted`.
    * @type {string}
    * @memberof AdminApiSetDiscoverabilityOfWorkspace
    */
    readonly discoverability: string
    
    /**
    * The ID of the workspace to set discoverability on.
    * @type {string}
    * @memberof AdminApiSetDiscoverabilityOfWorkspace
    */
    readonly teamId: string
    
} & AdminteamssettingsSetDiscoverabilityOfWorkspaceRequest

/**
 * Request parameters for setExpirationGuest operation in AdminApi.
 * @export
 * @interface AdminApiSetExpirationGuestRequest
 */
export type AdminApiSetExpirationGuestRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiSetExpirationGuest
    */
    readonly token: string
    
    /**
    * Timestamp when guest account should be disabled.
    * @type {number}
    * @memberof AdminApiSetExpirationGuest
    */
    readonly expirationTs: number
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiSetExpirationGuest
    */
    readonly teamId: string
    
    /**
    * The ID of the user to set an expiration for.
    * @type {string}
    * @memberof AdminApiSetExpirationGuest
    */
    readonly userId: string
    
} & AdminusersSetExpirationGuestRequest

/**
 * Request parameters for setIcon operation in AdminApi.
 * @export
 * @interface AdminApiSetIconRequest
 */
export type AdminApiSetIconRequest = {
    
    /**
    * Image URL for the icon
    * @type {string}
    * @memberof AdminApiSetIcon
    */
    readonly imageUrl: string
    
    /**
    * ID for the workspace to set the icon for.
    * @type {string}
    * @memberof AdminApiSetIcon
    */
    readonly teamId: string
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiSetIcon
    */
    readonly token: string
    
} & AdminteamssettingsSetIconRequest

/**
 * Request parameters for setName operation in AdminApi.
 * @export
 * @interface AdminApiSetNameRequest
 */
export type AdminApiSetNameRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.teams:write`
    * @type {string}
    * @memberof AdminApiSetName
    */
    readonly token: string
    
    /**
    * The new name of the workspace.
    * @type {string}
    * @memberof AdminApiSetName
    */
    readonly name: string
    
    /**
    * ID for the workspace to set the name for.
    * @type {string}
    * @memberof AdminApiSetName
    */
    readonly teamId: string
    
} & AdminteamssettingsSetNameRequest

/**
 * Request parameters for setRegularUser operation in AdminApi.
 * @export
 * @interface AdminApiSetRegularUserRequest
 */
export type AdminApiSetRegularUserRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiSetRegularUser
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiSetRegularUser
    */
    readonly teamId: string
    
    /**
    * The ID of the user to designate as a regular user.
    * @type {string}
    * @memberof AdminApiSetRegularUser
    */
    readonly userId: string
    
} & AdminusersSetRegularUserRequest

/**
 * Request parameters for setTeamsWorkspaceConnection operation in AdminApi.
 * @export
 * @interface AdminApiSetTeamsWorkspaceConnectionRequest
 */
export type AdminApiSetTeamsWorkspaceConnectionRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiSetTeamsWorkspaceConnection
    */
    readonly token: string
    
    /**
    * The encoded `channel_id` to add or remove to workspaces.
    * @type {string}
    * @memberof AdminApiSetTeamsWorkspaceConnection
    */
    readonly channelId: string
    
    /**
    * True if channel has to be converted to an org channel
    * @type {boolean}
    * @memberof AdminApiSetTeamsWorkspaceConnection
    */
    readonly orgChannel?: boolean
    
    /**
    * A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
    * @type {string}
    * @memberof AdminApiSetTeamsWorkspaceConnection
    */
    readonly targetTeamIds?: string
    
    /**
    * The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
    * @type {string}
    * @memberof AdminApiSetTeamsWorkspaceConnection
    */
    readonly teamId?: string
    
} & AdminconversationsSetTeamsWorkspaceConnectionRequest

/**
 * Request parameters for setWorkspaceOwner operation in AdminApi.
 * @export
 * @interface AdminApiSetWorkspaceOwnerRequest
 */
export type AdminApiSetWorkspaceOwnerRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.users:write`
    * @type {string}
    * @memberof AdminApiSetWorkspaceOwner
    */
    readonly token: string
    
    /**
    * The ID (`T1234`) of the workspace.
    * @type {string}
    * @memberof AdminApiSetWorkspaceOwner
    */
    readonly teamId: string
    
    /**
    * Id of the user to promote to owner.
    * @type {string}
    * @memberof AdminApiSetWorkspaceOwner
    */
    readonly userId: string
    
} & AdminusersSetWorkspaceOwnerRequest

/**
 * Request parameters for unarchiveChannel operation in AdminApi.
 * @export
 * @interface AdminApiUnarchiveChannelRequest
 */
export type AdminApiUnarchiveChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminApiUnarchiveChannel
    */
    readonly token: string
    
    /**
    * The channel to unarchive.
    * @type {string}
    * @memberof AdminApiUnarchiveChannel
    */
    readonly channelId: string
    
} & AdminconversationsUnarchiveChannelRequest

/**
 * AdminApiGenerated - object-oriented interface
 * @export
 * @class AdminApiGenerated
 * @extends {BaseAPI}
 */
export class AdminApiGenerated extends BaseAPI {
    /**
     * Add one or more default channels to an IDP group.
     * @param {AdminApiAddDefaultChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public addDefaultChannels(requestParameters: AdminApiAddDefaultChannelsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addDefaultChannels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an emoji.
     * @param {AdminApiAddEmojiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public addEmoji(requestParameters: AdminApiAddEmojiRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addEmoji(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an allowlist of IDP groups for accessing a channel
     * @param {AdminApiAddGroupIdpGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public addGroupIdpGroups(requestParameters: AdminApiAddGroupIdpGroupsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addGroupIdpGroups(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an Enterprise user to a workspace.
     * @param {AdminApiAddWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public addWorkspaceUser(requestParameters: AdminApiAddWorkspaceUserRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addWorkspaceUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an emoji alias.
     * @param {AdminApiAliasAddRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public aliasAdd(requestParameters: AdminApiAliasAddRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).aliasAdd(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve an app for installation on a workspace.
     * @param {AdminApiApproveAppInstallationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public approveAppInstallation(requestParameters: AdminApiApproveAppInstallationRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).approveAppInstallation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve a workspace invite request.
     * @param {AdminApiApproveRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public approveRequest(requestParameters: AdminApiApproveRequestRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).approveRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive a public or private channel.
     * @param {AdminApiArchiveChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public archiveChannel(requestParameters: AdminApiArchiveChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).archiveChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Associate one or more default workspaces with an organization-wide IDP group.
     * @param {AdminApiAssociateDefaultWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public associateDefaultWorkspaces(requestParameters: AdminApiAssociateDefaultWorkspacesRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).associateDefaultWorkspaces(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Convert a public channel to a private channel.
     * @param {AdminApiConvertToPrivateChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public convertToPrivateChannel(requestParameters: AdminApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).convertToPrivateChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a public or private channel-based conversation.
     * @param {AdminApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public createChannelBasedConversation(requestParameters: AdminApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createChannelBasedConversation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Enterprise team.
     * @param {AdminApiCreateEnterpriseTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public createEnterpriseTeam(requestParameters: AdminApiCreateEnterpriseTeamRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).createEnterpriseTeam(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public or private channel.
     * @param {AdminApiDeleteChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public deleteChannel(requestParameters: AdminApiDeleteChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deny a workspace invite request.
     * @param {AdminApiDenyRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public denyRequest(requestParameters: AdminApiDenyRequestRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).denyRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect a connected channel from one or more workspaces.
     * @param {AdminApiDisconnectSharedChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public disconnectSharedChannel(requestParameters: AdminApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).disconnectSharedChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the admins on a given workspace.
     * @param {AdminApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public getAll(requestParameters: AdminApiGetAllRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAll(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation preferences for a public or private channel.
     * @param {AdminApiGetConversationPrefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public getConversationPrefs(requestParameters: AdminApiGetConversationPrefsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getConversationPrefs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch information about settings in a workspace
     * @param {AdminApiGetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public getInfo(requestParameters: AdminApiGetInfoRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List restricted apps for an org or workspace.
     * @param {AdminApiGetListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public getList(requestParameters: AdminApiGetListRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
     * @param {AdminApiGetTeamsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public getTeamsList(requestParameters: AdminApiGetTeamsListRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getTeamsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidate a single session for a user by session_id
     * @param {AdminApiInvalidateSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public invalidateSession(requestParameters: AdminApiInvalidateSessionRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).invalidateSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to a public or private channel.
     * @param {AdminApiInviteUserToChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public inviteUserToChannel(requestParameters: AdminApiInviteUserToChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).inviteUserToChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to a workspace.
     * @param {AdminApiInviteUserToWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public inviteUserToWorkspace(requestParameters: AdminApiInviteUserToWorkspaceRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).inviteUserToWorkspace(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List approved apps for an org or workspace.
     * @param {AdminApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public list(requestParameters: AdminApiListRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all teams on an Enterprise organization
     * @param {AdminApiListAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listAll(requestParameters: AdminApiListAllRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listAll(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the channels linked to an org-level IDP group (user group).
     * @param {AdminApiListChannelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listChannelsGet(requestParameters: AdminApiListChannelsGetRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listChannelsGet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List emoji for an Enterprise Grid organization.
     * @param {AdminApiListEnterpriseEmojiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listEnterpriseEmoji(requestParameters: AdminApiListEnterpriseEmojiRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listEnterpriseEmoji(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all IDP Groups linked to a channel
     * @param {AdminApiListGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listGroups(requestParameters: AdminApiListGroupsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listGroups(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
     * @param {AdminApiListOriginalConnectedChannelInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listOriginalConnectedChannelInfo(requestParameters: AdminApiListOriginalConnectedChannelInfoRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listOriginalConnectedChannelInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the owners on a given workspace.
     * @param {AdminApiListOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listOwners(requestParameters: AdminApiListOwnersRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listOwners(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all pending workspace invite requests.
     * @param {AdminApiListPendingWorkspaceInviteRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listPendingWorkspaceInviteRequests(requestParameters: AdminApiListPendingWorkspaceInviteRequestsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listPendingWorkspaceInviteRequests(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users on a workspace
     * @param {AdminApiListWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public listWorkspaceUsers(requestParameters: AdminApiListWorkspaceUsersRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).listWorkspaceUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List app requests for a team/workspace.
     * @param {AdminApiList0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public list_1(requestParameters: AdminApiList0Request, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).list_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all approved workspace invite requests.
     * @param {AdminApiList1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public list_2(requestParameters: AdminApiList1Request, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).list_2(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all denied workspace invite requests.
     * @param {AdminApiList2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public list_3(requestParameters: AdminApiList2Request, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).list_3(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove one or more default channels from an org-level IDP group (user group).
     * @param {AdminApiRemoveChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public removeChannels(requestParameters: AdminApiRemoveChannelsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).removeChannels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an emoji across an Enterprise Grid organization
     * @param {AdminApiRemoveEnterpriseEmojiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public removeEnterpriseEmoji(requestParameters: AdminApiRemoveEnterpriseEmojiRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).removeEnterpriseEmoji(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a linked IDP group linked from a private channel
     * @param {AdminApiRemoveIdpGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public removeIdpGroup(requestParameters: AdminApiRemoveIdpGroupRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).removeIdpGroup(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a user from a workspace.
     * @param {AdminApiRemoveUserFromWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public removeUserFromWorkspace(requestParameters: AdminApiRemoveUserFromWorkspaceRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).removeUserFromWorkspace(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename a public or private channel.
     * @param {AdminApiRenameChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public renameChannel(requestParameters: AdminApiRenameChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).renameChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename an emoji.
     * @param {AdminApiRenameEmojiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public renameEmoji(requestParameters: AdminApiRenameEmojiRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).renameEmoji(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Wipes all valid sessions on all devices for a given user
     * @param {AdminApiResetSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public resetSessions(requestParameters: AdminApiResetSessionsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).resetSessions(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restrict an app for installation on a workspace.
     * @param {AdminApiRestrictAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public restrictApp(requestParameters: AdminApiRestrictAppRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).restrictApp(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for public or private channels in an Enterprise organization.
     * @param {AdminApiSearchChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public searchChannels(requestParameters: AdminApiSearchChannelsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).searchChannels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an existing guest, regular user, or owner to be an admin user.
     * @param {AdminApiSetAdminUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setAdminUser(requestParameters: AdminApiSetAdminUserRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setAdminUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the posting permissions for a public or private channel.
     * @param {AdminApiSetConversationPrefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setConversationPrefs(requestParameters: AdminApiSetConversationPrefsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setConversationPrefs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the default channels of a workspace.
     * @param {AdminApiSetDefaultChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setDefaultChannels(requestParameters: AdminApiSetDefaultChannelsRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setDefaultChannels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the description of a given workspace.
     * @param {AdminApiSetDescriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setDescription(requestParameters: AdminApiSetDescriptionRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setDescription(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * An API method that allows admins to set the discoverability of a given workspace
     * @param {AdminApiSetDiscoverabilityOfWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setDiscoverabilityOfWorkspace(requestParameters: AdminApiSetDiscoverabilityOfWorkspaceRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setDiscoverabilityOfWorkspace(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an expiration for a guest user
     * @param {AdminApiSetExpirationGuestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setExpirationGuest(requestParameters: AdminApiSetExpirationGuestRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setExpirationGuest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the icon of a workspace.
     * @param {AdminApiSetIconRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setIcon(requestParameters: AdminApiSetIconRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setIcon(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the name of a given workspace.
     * @param {AdminApiSetNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setName(requestParameters: AdminApiSetNameRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setName(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an existing guest user, admin user, or owner to be a regular user.
     * @param {AdminApiSetRegularUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setRegularUser(requestParameters: AdminApiSetRegularUserRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setRegularUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
     * @param {AdminApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setTeamsWorkspaceConnection(requestParameters: AdminApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setTeamsWorkspaceConnection(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an existing guest, regular user, or admin user to be a workspace owner.
     * @param {AdminApiSetWorkspaceOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public setWorkspaceOwner(requestParameters: AdminApiSetWorkspaceOwnerRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setWorkspaceOwner(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unarchive a public or private channel.
     * @param {AdminApiUnarchiveChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApiGenerated
     */
    public unarchiveChannel(requestParameters: AdminApiUnarchiveChannelRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).unarchiveChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
