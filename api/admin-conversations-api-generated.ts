/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AdminconversationsArchiveChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsArchiveChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsArchiveChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsConvertToPrivateChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationRequest } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationResponse } from '../models';
// @ts-ignore
import { AdminconversationsCreateChannelBasedConversationdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsDeleteChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsDisconnectSharedChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetConversationPrefsResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetConversationPrefsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetTeamsListResponse } from '../models';
// @ts-ignore
import { AdminconversationsGetTeamsListdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsInviteUserToChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsRenameChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsRenameChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsRenameChanneldefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSearchChannelsResponse } from '../models';
// @ts-ignore
import { AdminconversationsSearchChannelsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsRequest } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetConversationPrefsdefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectionRequest } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectionResponse } from '../models';
// @ts-ignore
import { AdminconversationsSetTeamsWorkspaceConnectiondefaultResponse } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChannelRequest } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChannelResponse } from '../models';
// @ts-ignore
import { AdminconversationsUnarchiveChanneldefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AdminConversationsApi - axios parameter creator
 * @export
 */
export const AdminConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to archive.
         * @param {AdminconversationsArchiveChannelRequest} adminconversationsArchiveChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChannel: async (token: string, channelId: string, adminconversationsArchiveChannelRequest: AdminconversationsArchiveChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('archiveChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('archiveChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsArchiveChannelRequest' is not null or undefined
            assertParamExists('archiveChannel', 'adminconversationsArchiveChannelRequest', adminconversationsArchiveChannelRequest)
            const localVarPath = `/admin.conversations.archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsArchiveChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.archive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsArchiveChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Convert a public channel to a private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to convert to private.
         * @param {AdminconversationsConvertToPrivateChannelRequest} adminconversationsConvertToPrivateChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPrivateChannel: async (token: string, channelId: string, adminconversationsConvertToPrivateChannelRequest: AdminconversationsConvertToPrivateChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsConvertToPrivateChannelRequest' is not null or undefined
            assertParamExists('convertToPrivateChannel', 'adminconversationsConvertToPrivateChannelRequest', adminconversationsConvertToPrivateChannelRequest)
            const localVarPath = `/admin.conversations.convertToPrivate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsConvertToPrivateChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.convertToPrivate',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsConvertToPrivateChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {boolean} isPrivate When &#x60;true&#x60;, creates a private channel instead of a public channel
         * @param {string} name Name of the public or private channel to create.
         * @param {AdminconversationsCreateChannelBasedConversationRequest} adminconversationsCreateChannelBasedConversationRequest 
         * @param {string} [description] Description of the public or private channel to create.
         * @param {boolean} [orgWide] When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel
         * @param {string} [teamId] The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelBasedConversation: async (token: string, isPrivate: boolean, name: string, adminconversationsCreateChannelBasedConversationRequest: AdminconversationsCreateChannelBasedConversationRequest, description?: string, orgWide?: boolean, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'token', token)
            // verify required parameter 'isPrivate' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'isPrivate', isPrivate)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'name', name)
            // verify required parameter 'adminconversationsCreateChannelBasedConversationRequest' is not null or undefined
            assertParamExists('createChannelBasedConversation', 'adminconversationsCreateChannelBasedConversationRequest', adminconversationsCreateChannelBasedConversationRequest)
            const localVarPath = `/admin.conversations.create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (description !== undefined) {
                await addFormParam('description', description, false, true)
            }
    
            if (isPrivate !== undefined) {
                await addFormParam('is_private', isPrivate, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (orgWide !== undefined) {
                await addFormParam('org_wide', orgWide, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsCreateChannelBasedConversationRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.create',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsCreateChannelBasedConversationRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to delete.
         * @param {AdminconversationsDeleteChannelRequest} adminconversationsDeleteChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel: async (token: string, channelId: string, adminconversationsDeleteChannelRequest: AdminconversationsDeleteChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsDeleteChannelRequest' is not null or undefined
            assertParamExists('deleteChannel', 'adminconversationsDeleteChannelRequest', adminconversationsDeleteChannelRequest)
            const localVarPath = `/admin.conversations.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsDeleteChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.delete',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsDeleteChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to be disconnected from some workspaces.
         * @param {AdminconversationsDisconnectSharedChannelRequest} adminconversationsDisconnectSharedChannelRequest 
         * @param {string} [leavingTeamIds] The team to be removed from the channel. Currently only a single team id can be specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSharedChannel: async (token: string, channelId: string, adminconversationsDisconnectSharedChannelRequest: AdminconversationsDisconnectSharedChannelRequest, leavingTeamIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsDisconnectSharedChannelRequest' is not null or undefined
            assertParamExists('disconnectSharedChannel', 'adminconversationsDisconnectSharedChannelRequest', adminconversationsDisconnectSharedChannelRequest)
            const localVarPath = `/admin.conversations.disconnectShared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (leavingTeamIds !== undefined) {
                await addFormParam('leaving_team_ids', leavingTeamIds, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsDisconnectSharedChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.disconnectShared',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsDisconnectSharedChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} channelId The channel to get preferences for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationPrefs: async (token: string, channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getConversationPrefs', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getConversationPrefs', 'channelId', channelId)
            const localVarPath = `/admin.conversations.getConversationPrefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.getConversationPrefs',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} channelId The channel to determine connected workspaces within the organization for.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page
         * @param {number} [limit] The maximum number of items to return. Must be between 1 - 1000 both inclusive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsList: async (token: string, channelId: string, cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getTeamsList', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getTeamsList', 'channelId', channelId)
            const localVarPath = `/admin.conversations.getTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (channelId !== undefined) {
                localVarQueryParameter['channel_id'] = channelId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.getTeams',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel that the users will be invited to.
         * @param {string} userIds The users to invite.
         * @param {AdminconversationsInviteUserToChannelRequest} adminconversationsInviteUserToChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToChannel: async (token: string, channelId: string, userIds: string, adminconversationsInviteUserToChannelRequest: AdminconversationsInviteUserToChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('inviteUserToChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('inviteUserToChannel', 'channelId', channelId)
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('inviteUserToChannel', 'userIds', userIds)
            // verify required parameter 'adminconversationsInviteUserToChannelRequest' is not null or undefined
            assertParamExists('inviteUserToChannel', 'adminconversationsInviteUserToChannelRequest', adminconversationsInviteUserToChannelRequest)
            const localVarPath = `/admin.conversations.invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (userIds !== undefined) {
                await addFormParam('user_ids', userIds, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsInviteUserToChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.invite',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsInviteUserToChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to rename.
         * @param {string} name 
         * @param {AdminconversationsRenameChannelRequest} adminconversationsRenameChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameChannel: async (token: string, channelId: string, name: string, adminconversationsRenameChannelRequest: AdminconversationsRenameChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('renameChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('renameChannel', 'channelId', channelId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('renameChannel', 'name', name)
            // verify required parameter 'adminconversationsRenameChannelRequest' is not null or undefined
            assertParamExists('renameChannel', 'adminconversationsRenameChannelRequest', adminconversationsRenameChannelRequest)
            const localVarPath = `/admin.conversations.rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsRenameChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.rename',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsRenameChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60;
         * @param {string} [teamIds] Comma separated string of team IDs, signifying the workspaces to search through.
         * @param {string} [query] Name of the the channel to query by.
         * @param {number} [limit] Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
         * @param {string} [cursor] Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page.
         * @param {string} [searchChannelTypes] The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](https://slack.dev).
         * @param {string} [sort] Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted 
         * @param {string} [sortDir] Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChannels: async (token: string, teamIds?: string, query?: string, limit?: number, cursor?: string, searchChannelTypes?: string, sort?: string, sortDir?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('searchChannels', 'token', token)
            const localVarPath = `/admin.conversations.search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:read"], configuration)
            if (teamIds !== undefined) {
                localVarQueryParameter['team_ids'] = teamIds;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (searchChannelTypes !== undefined) {
                localVarQueryParameter['search_channel_types'] = searchChannelTypes;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.search',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to set the prefs for
         * @param {string} prefs The prefs for this channel in a stringified JSON format.
         * @param {AdminconversationsSetConversationPrefsRequest} adminconversationsSetConversationPrefsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConversationPrefs: async (token: string, channelId: string, prefs: string, adminconversationsSetConversationPrefsRequest: AdminconversationsSetConversationPrefsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setConversationPrefs', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setConversationPrefs', 'channelId', channelId)
            // verify required parameter 'prefs' is not null or undefined
            assertParamExists('setConversationPrefs', 'prefs', prefs)
            // verify required parameter 'adminconversationsSetConversationPrefsRequest' is not null or undefined
            assertParamExists('setConversationPrefs', 'adminconversationsSetConversationPrefsRequest', adminconversationsSetConversationPrefsRequest)
            const localVarPath = `/admin.conversations.setConversationPrefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (prefs !== undefined) {
                await addFormParam('prefs', prefs, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsSetConversationPrefsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.setConversationPrefs',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsSetConversationPrefsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The encoded &#x60;channel_id&#x60; to add or remove to workspaces.
         * @param {AdminconversationsSetTeamsWorkspaceConnectionRequest} adminconversationsSetTeamsWorkspaceConnectionRequest 
         * @param {boolean} [orgChannel] True if channel has to be converted to an org channel
         * @param {string} [targetTeamIds] A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
         * @param {string} [teamId] The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamsWorkspaceConnection: async (token: string, channelId: string, adminconversationsSetTeamsWorkspaceConnectionRequest: AdminconversationsSetTeamsWorkspaceConnectionRequest, orgChannel?: boolean, targetTeamIds?: string, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'channelId', channelId)
            // verify required parameter 'adminconversationsSetTeamsWorkspaceConnectionRequest' is not null or undefined
            assertParamExists('setTeamsWorkspaceConnection', 'adminconversationsSetTeamsWorkspaceConnectionRequest', adminconversationsSetTeamsWorkspaceConnectionRequest)
            const localVarPath = `/admin.conversations.setTeams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
            if (orgChannel !== undefined) {
                await addFormParam('org_channel', orgChannel, false, true)
            }
    
            if (targetTeamIds !== undefined) {
                await addFormParam('target_team_ids', targetTeamIds, false, true)
            }
    
            if (teamId !== undefined) {
                await addFormParam('team_id', teamId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsSetTeamsWorkspaceConnectionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.setTeams',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsSetTeamsWorkspaceConnectionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchive a public or private channel.
         * @param {string} token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60;
         * @param {string} channelId The channel to unarchive.
         * @param {AdminconversationsUnarchiveChannelRequest} adminconversationsUnarchiveChannelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveChannel: async (token: string, channelId: string, adminconversationsUnarchiveChannelRequest: AdminconversationsUnarchiveChannelRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('unarchiveChannel', 'token', token)
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('unarchiveChannel', 'channelId', channelId)
            // verify required parameter 'adminconversationsUnarchiveChannelRequest' is not null or undefined
            assertParamExists('unarchiveChannel', 'adminconversationsUnarchiveChannelRequest', adminconversationsUnarchiveChannelRequest)
            const localVarPath = `/admin.conversations.unarchive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["admin.conversations:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channelId !== undefined) {
                await addFormParam('channel_id', channelId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: adminconversationsUnarchiveChannelRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/admin.conversations.unarchive',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(adminconversationsUnarchiveChannelRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminConversationsApi - functional programming interface
 * @export
 */
export const AdminConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive a public or private channel.
         * @param {AdminConversationsApiArchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveChannel(requestParameters: AdminConversationsApiArchiveChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsArchiveChannelResponse>> {
            const adminconversationsArchiveChannelRequest: AdminconversationsArchiveChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveChannel(requestParameters.token, requestParameters.channelId, adminconversationsArchiveChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Convert a public channel to a private channel.
         * @param {AdminConversationsApiConvertToPrivateChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertToPrivateChannel(requestParameters: AdminConversationsApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsConvertToPrivateChannelResponse>> {
            const adminconversationsConvertToPrivateChannelRequest: AdminconversationsConvertToPrivateChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertToPrivateChannel(requestParameters.token, requestParameters.channelId, adminconversationsConvertToPrivateChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {AdminConversationsApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannelBasedConversation(requestParameters: AdminConversationsApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsCreateChannelBasedConversationResponse>> {
            const adminconversationsCreateChannelBasedConversationRequest: AdminconversationsCreateChannelBasedConversationRequest = {
                description: requestParameters.description,
                is_private: requestParameters.is_private,
                name: requestParameters.name,
                org_wide: requestParameters.org_wide,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChannelBasedConversation(requestParameters.token, requestParameters.isPrivate, requestParameters.name, adminconversationsCreateChannelBasedConversationRequest, requestParameters.description, requestParameters.orgWide, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a public or private channel.
         * @param {AdminConversationsApiDeleteChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannel(requestParameters: AdminConversationsApiDeleteChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsDeleteChannelResponse>> {
            const adminconversationsDeleteChannelRequest: AdminconversationsDeleteChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(requestParameters.token, requestParameters.channelId, adminconversationsDeleteChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {AdminConversationsApiDisconnectSharedChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectSharedChannel(requestParameters: AdminConversationsApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsDisconnectSharedChannelResponse>> {
            const adminconversationsDisconnectSharedChannelRequest: AdminconversationsDisconnectSharedChannelRequest = {
                channel_id: requestParameters.channel_id,
                leaving_team_ids: requestParameters.leaving_team_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectSharedChannel(requestParameters.token, requestParameters.channelId, adminconversationsDisconnectSharedChannelRequest, requestParameters.leavingTeamIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {AdminConversationsApiGetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationPrefs(requestParameters: AdminConversationsApiGetConversationPrefsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsGetConversationPrefsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationPrefs(requestParameters.token, requestParameters.channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {AdminConversationsApiGetTeamsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsList(requestParameters: AdminConversationsApiGetTeamsListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsGetTeamsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsList(requestParameters.token, requestParameters.channelId, requestParameters.cursor, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invite a user to a public or private channel.
         * @param {AdminConversationsApiInviteUserToChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserToChannel(requestParameters: AdminConversationsApiInviteUserToChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsInviteUserToChannelResponse>> {
            const adminconversationsInviteUserToChannelRequest: AdminconversationsInviteUserToChannelRequest = {
                channel_id: requestParameters.channel_id,
                user_ids: requestParameters.user_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserToChannel(requestParameters.token, requestParameters.channelId, requestParameters.userIds, adminconversationsInviteUserToChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rename a public or private channel.
         * @param {AdminConversationsApiRenameChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameChannel(requestParameters: AdminConversationsApiRenameChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsRenameChannelResponse>> {
            const adminconversationsRenameChannelRequest: AdminconversationsRenameChannelRequest = {
                channel_id: requestParameters.channel_id,
                name: requestParameters.name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameChannel(requestParameters.token, requestParameters.channelId, requestParameters.name, adminconversationsRenameChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {AdminConversationsApiSearchChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChannels(requestParameters: AdminConversationsApiSearchChannelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSearchChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChannels(requestParameters.token, requestParameters.teamIds, requestParameters.query, requestParameters.limit, requestParameters.cursor, requestParameters.searchChannelTypes, requestParameters.sort, requestParameters.sortDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {AdminConversationsApiSetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConversationPrefs(requestParameters: AdminConversationsApiSetConversationPrefsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSetConversationPrefsResponse>> {
            const adminconversationsSetConversationPrefsRequest: AdminconversationsSetConversationPrefsRequest = {
                channel_id: requestParameters.channel_id,
                prefs: requestParameters.prefs
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConversationPrefs(requestParameters.token, requestParameters.channelId, requestParameters.prefs, adminconversationsSetConversationPrefsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {AdminConversationsApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTeamsWorkspaceConnection(requestParameters: AdminConversationsApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsSetTeamsWorkspaceConnectionResponse>> {
            const adminconversationsSetTeamsWorkspaceConnectionRequest: AdminconversationsSetTeamsWorkspaceConnectionRequest = {
                channel_id: requestParameters.channel_id,
                org_channel: requestParameters.org_channel,
                target_team_ids: requestParameters.target_team_ids,
                team_id: requestParameters.team_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTeamsWorkspaceConnection(requestParameters.token, requestParameters.channelId, adminconversationsSetTeamsWorkspaceConnectionRequest, requestParameters.orgChannel, requestParameters.targetTeamIds, requestParameters.teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unarchive a public or private channel.
         * @param {AdminConversationsApiUnarchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveChannel(requestParameters: AdminConversationsApiUnarchiveChannelRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminconversationsUnarchiveChannelResponse>> {
            const adminconversationsUnarchiveChannelRequest: AdminconversationsUnarchiveChannelRequest = {
                channel_id: requestParameters.channel_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveChannel(requestParameters.token, requestParameters.channelId, adminconversationsUnarchiveChannelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminConversationsApi - factory interface
 * @export
 */
export const AdminConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminConversationsApiFp(configuration)
    return {
        /**
         * Archive a public or private channel.
         * @param {AdminConversationsApiArchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveChannel(requestParameters: AdminConversationsApiArchiveChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsArchiveChannelResponse> {
            return localVarFp.archiveChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Convert a public channel to a private channel.
         * @param {AdminConversationsApiConvertToPrivateChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToPrivateChannel(requestParameters: AdminConversationsApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsConvertToPrivateChannelResponse> {
            return localVarFp.convertToPrivateChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a public or private channel-based conversation.
         * @param {AdminConversationsApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannelBasedConversation(requestParameters: AdminConversationsApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsCreateChannelBasedConversationResponse> {
            return localVarFp.createChannelBasedConversation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a public or private channel.
         * @param {AdminConversationsApiDeleteChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannel(requestParameters: AdminConversationsApiDeleteChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsDeleteChannelResponse> {
            return localVarFp.deleteChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect a connected channel from one or more workspaces.
         * @param {AdminConversationsApiDisconnectSharedChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectSharedChannel(requestParameters: AdminConversationsApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsDisconnectSharedChannelResponse> {
            return localVarFp.disconnectSharedChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation preferences for a public or private channel.
         * @param {AdminConversationsApiGetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationPrefs(requestParameters: AdminConversationsApiGetConversationPrefsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsGetConversationPrefsResponse> {
            return localVarFp.getConversationPrefs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
         * @param {AdminConversationsApiGetTeamsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsList(requestParameters: AdminConversationsApiGetTeamsListRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsGetTeamsListResponse> {
            return localVarFp.getTeamsList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to a public or private channel.
         * @param {AdminConversationsApiInviteUserToChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserToChannel(requestParameters: AdminConversationsApiInviteUserToChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsInviteUserToChannelResponse> {
            return localVarFp.inviteUserToChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Rename a public or private channel.
         * @param {AdminConversationsApiRenameChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameChannel(requestParameters: AdminConversationsApiRenameChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsRenameChannelResponse> {
            return localVarFp.renameChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for public or private channels in an Enterprise organization.
         * @param {AdminConversationsApiSearchChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChannels(requestParameters: AdminConversationsApiSearchChannelsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSearchChannelsResponse> {
            return localVarFp.searchChannels(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the posting permissions for a public or private channel.
         * @param {AdminConversationsApiSetConversationPrefsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConversationPrefs(requestParameters: AdminConversationsApiSetConversationPrefsRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSetConversationPrefsResponse> {
            return localVarFp.setConversationPrefs(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
         * @param {AdminConversationsApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamsWorkspaceConnection(requestParameters: AdminConversationsApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsSetTeamsWorkspaceConnectionResponse> {
            return localVarFp.setTeamsWorkspaceConnection(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Unarchive a public or private channel.
         * @param {AdminConversationsApiUnarchiveChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveChannel(requestParameters: AdminConversationsApiUnarchiveChannelRequest, options?: AxiosRequestConfig): AxiosPromise<AdminconversationsUnarchiveChannelResponse> {
            return localVarFp.unarchiveChannel(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archiveChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiArchiveChannelRequest
 */
export type AdminConversationsApiArchiveChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiArchiveChannel
    */
    readonly token: string
    
    /**
    * The channel to archive.
    * @type {string}
    * @memberof AdminConversationsApiArchiveChannel
    */
    readonly channelId: string
    
} & AdminconversationsArchiveChannelRequest

/**
 * Request parameters for convertToPrivateChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiConvertToPrivateChannelRequest
 */
export type AdminConversationsApiConvertToPrivateChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiConvertToPrivateChannel
    */
    readonly token: string
    
    /**
    * The channel to convert to private.
    * @type {string}
    * @memberof AdminConversationsApiConvertToPrivateChannel
    */
    readonly channelId: string
    
} & AdminconversationsConvertToPrivateChannelRequest

/**
 * Request parameters for createChannelBasedConversation operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiCreateChannelBasedConversationRequest
 */
export type AdminConversationsApiCreateChannelBasedConversationRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly token: string
    
    /**
    * When `true`, creates a private channel instead of a public channel
    * @type {boolean}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly isPrivate: boolean
    
    /**
    * Name of the public or private channel to create.
    * @type {string}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly name: string
    
    /**
    * Description of the public or private channel to create.
    * @type {string}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly description?: string
    
    /**
    * When `true`, the channel will be available org-wide. Note: if the channel is not `org_wide=true`, you must specify a `team_id` for this channel
    * @type {boolean}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly orgWide?: boolean
    
    /**
    * The workspace to create the channel in. Note: this argument is required unless you set `org_wide=true`.
    * @type {string}
    * @memberof AdminConversationsApiCreateChannelBasedConversation
    */
    readonly teamId?: string
    
} & AdminconversationsCreateChannelBasedConversationRequest

/**
 * Request parameters for deleteChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiDeleteChannelRequest
 */
export type AdminConversationsApiDeleteChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiDeleteChannel
    */
    readonly token: string
    
    /**
    * The channel to delete.
    * @type {string}
    * @memberof AdminConversationsApiDeleteChannel
    */
    readonly channelId: string
    
} & AdminconversationsDeleteChannelRequest

/**
 * Request parameters for disconnectSharedChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiDisconnectSharedChannelRequest
 */
export type AdminConversationsApiDisconnectSharedChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiDisconnectSharedChannel
    */
    readonly token: string
    
    /**
    * The channel to be disconnected from some workspaces.
    * @type {string}
    * @memberof AdminConversationsApiDisconnectSharedChannel
    */
    readonly channelId: string
    
    /**
    * The team to be removed from the channel. Currently only a single team id can be specified.
    * @type {string}
    * @memberof AdminConversationsApiDisconnectSharedChannel
    */
    readonly leavingTeamIds?: string
    
} & AdminconversationsDisconnectSharedChannelRequest

/**
 * Request parameters for getConversationPrefs operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiGetConversationPrefsRequest
 */
export type AdminConversationsApiGetConversationPrefsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminConversationsApiGetConversationPrefs
    */
    readonly token: string
    
    /**
    * The channel to get preferences for.
    * @type {string}
    * @memberof AdminConversationsApiGetConversationPrefs
    */
    readonly channelId: string
    
}

/**
 * Request parameters for getTeamsList operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiGetTeamsListRequest
 */
export type AdminConversationsApiGetTeamsListRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminConversationsApiGetTeamsList
    */
    readonly token: string
    
    /**
    * The channel to determine connected workspaces within the organization for.
    * @type {string}
    * @memberof AdminConversationsApiGetTeamsList
    */
    readonly channelId: string
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page
    * @type {string}
    * @memberof AdminConversationsApiGetTeamsList
    */
    readonly cursor?: string
    
    /**
    * The maximum number of items to return. Must be between 1 - 1000 both inclusive.
    * @type {number}
    * @memberof AdminConversationsApiGetTeamsList
    */
    readonly limit?: number
    
}

/**
 * Request parameters for inviteUserToChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiInviteUserToChannelRequest
 */
export type AdminConversationsApiInviteUserToChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiInviteUserToChannel
    */
    readonly token: string
    
    /**
    * The channel that the users will be invited to.
    * @type {string}
    * @memberof AdminConversationsApiInviteUserToChannel
    */
    readonly channelId: string
    
    /**
    * The users to invite.
    * @type {string}
    * @memberof AdminConversationsApiInviteUserToChannel
    */
    readonly userIds: string
    
} & AdminconversationsInviteUserToChannelRequest

/**
 * Request parameters for renameChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiRenameChannelRequest
 */
export type AdminConversationsApiRenameChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiRenameChannel
    */
    readonly token: string
    
    /**
    * The channel to rename.
    * @type {string}
    * @memberof AdminConversationsApiRenameChannel
    */
    readonly channelId: string
    
    /**
    * 
    * @type {string}
    * @memberof AdminConversationsApiRenameChannel
    */
    readonly name: string
    
} & AdminconversationsRenameChannelRequest

/**
 * Request parameters for searchChannels operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiSearchChannelsRequest
 */
export type AdminConversationsApiSearchChannelsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:read`
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly token: string
    
    /**
    * Comma separated string of team IDs, signifying the workspaces to search through.
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly teamIds?: string
    
    /**
    * Name of the the channel to query by.
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly query?: string
    
    /**
    * Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10.
    * @type {number}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly limit?: number
    
    /**
    * Set `cursor` to `next_cursor` returned by the previous call to list items in the next page.
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly cursor?: string
    
    /**
    * The type of channel to include or exclude in the search. For example `private` will search private channels, while `private_exclude` will exclude them. For a full list of types, check the [Types section](https://slack.dev).
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly searchChannelTypes?: string
    
    /**
    * Possible values are `relevant` (search ranking based on what we think is closest), `name` (alphabetical), `member_count` (number of users in the channel), and `created` (date channel was created). You can optionally pair this with the `sort_dir` arg to change how it is sorted 
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly sort?: string
    
    /**
    * Sort direction. Possible values are `asc` for ascending order like (1, 2, 3) or (a, b, c), and `desc` for descending order like (3, 2, 1) or (c, b, a)
    * @type {string}
    * @memberof AdminConversationsApiSearchChannels
    */
    readonly sortDir?: string
    
}

/**
 * Request parameters for setConversationPrefs operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiSetConversationPrefsRequest
 */
export type AdminConversationsApiSetConversationPrefsRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiSetConversationPrefs
    */
    readonly token: string
    
    /**
    * The channel to set the prefs for
    * @type {string}
    * @memberof AdminConversationsApiSetConversationPrefs
    */
    readonly channelId: string
    
    /**
    * The prefs for this channel in a stringified JSON format.
    * @type {string}
    * @memberof AdminConversationsApiSetConversationPrefs
    */
    readonly prefs: string
    
} & AdminconversationsSetConversationPrefsRequest

/**
 * Request parameters for setTeamsWorkspaceConnection operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiSetTeamsWorkspaceConnectionRequest
 */
export type AdminConversationsApiSetTeamsWorkspaceConnectionRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiSetTeamsWorkspaceConnection
    */
    readonly token: string
    
    /**
    * The encoded `channel_id` to add or remove to workspaces.
    * @type {string}
    * @memberof AdminConversationsApiSetTeamsWorkspaceConnection
    */
    readonly channelId: string
    
    /**
    * True if channel has to be converted to an org channel
    * @type {boolean}
    * @memberof AdminConversationsApiSetTeamsWorkspaceConnection
    */
    readonly orgChannel?: boolean
    
    /**
    * A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide.
    * @type {string}
    * @memberof AdminConversationsApiSetTeamsWorkspaceConnection
    */
    readonly targetTeamIds?: string
    
    /**
    * The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel.
    * @type {string}
    * @memberof AdminConversationsApiSetTeamsWorkspaceConnection
    */
    readonly teamId?: string
    
} & AdminconversationsSetTeamsWorkspaceConnectionRequest

/**
 * Request parameters for unarchiveChannel operation in AdminConversationsApi.
 * @export
 * @interface AdminConversationsApiUnarchiveChannelRequest
 */
export type AdminConversationsApiUnarchiveChannelRequest = {
    
    /**
    * Authentication token. Requires scope: `admin.conversations:write`
    * @type {string}
    * @memberof AdminConversationsApiUnarchiveChannel
    */
    readonly token: string
    
    /**
    * The channel to unarchive.
    * @type {string}
    * @memberof AdminConversationsApiUnarchiveChannel
    */
    readonly channelId: string
    
} & AdminconversationsUnarchiveChannelRequest

/**
 * AdminConversationsApiGenerated - object-oriented interface
 * @export
 * @class AdminConversationsApiGenerated
 * @extends {BaseAPI}
 */
export class AdminConversationsApiGenerated extends BaseAPI {
    /**
     * Archive a public or private channel.
     * @param {AdminConversationsApiArchiveChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public archiveChannel(requestParameters: AdminConversationsApiArchiveChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).archiveChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Convert a public channel to a private channel.
     * @param {AdminConversationsApiConvertToPrivateChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public convertToPrivateChannel(requestParameters: AdminConversationsApiConvertToPrivateChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).convertToPrivateChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a public or private channel-based conversation.
     * @param {AdminConversationsApiCreateChannelBasedConversationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public createChannelBasedConversation(requestParameters: AdminConversationsApiCreateChannelBasedConversationRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).createChannelBasedConversation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a public or private channel.
     * @param {AdminConversationsApiDeleteChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public deleteChannel(requestParameters: AdminConversationsApiDeleteChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).deleteChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect a connected channel from one or more workspaces.
     * @param {AdminConversationsApiDisconnectSharedChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public disconnectSharedChannel(requestParameters: AdminConversationsApiDisconnectSharedChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).disconnectSharedChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation preferences for a public or private channel.
     * @param {AdminConversationsApiGetConversationPrefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public getConversationPrefs(requestParameters: AdminConversationsApiGetConversationPrefsRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).getConversationPrefs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the workspaces a given public or private channel is connected to within this Enterprise org.
     * @param {AdminConversationsApiGetTeamsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public getTeamsList(requestParameters: AdminConversationsApiGetTeamsListRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).getTeamsList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to a public or private channel.
     * @param {AdminConversationsApiInviteUserToChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public inviteUserToChannel(requestParameters: AdminConversationsApiInviteUserToChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).inviteUserToChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rename a public or private channel.
     * @param {AdminConversationsApiRenameChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public renameChannel(requestParameters: AdminConversationsApiRenameChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).renameChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for public or private channels in an Enterprise organization.
     * @param {AdminConversationsApiSearchChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public searchChannels(requestParameters: AdminConversationsApiSearchChannelsRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).searchChannels(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the posting permissions for a public or private channel.
     * @param {AdminConversationsApiSetConversationPrefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public setConversationPrefs(requestParameters: AdminConversationsApiSetConversationPrefsRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).setConversationPrefs(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the workspaces in an Enterprise grid org that connect to a public or private channel.
     * @param {AdminConversationsApiSetTeamsWorkspaceConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public setTeamsWorkspaceConnection(requestParameters: AdminConversationsApiSetTeamsWorkspaceConnectionRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).setTeamsWorkspaceConnection(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unarchive a public or private channel.
     * @param {AdminConversationsApiUnarchiveChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminConversationsApiGenerated
     */
    public unarchiveChannel(requestParameters: AdminConversationsApiUnarchiveChannelRequest, options?: AxiosRequestConfig) {
        return AdminConversationsApiFp(this.configuration).unarchiveChannel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
