/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ChatDeleteRequest } from '../models';
// @ts-ignore
import { ChatDeleteResponse } from '../models';
// @ts-ignore
import { ChatDeleteScheduledMessageRequest } from '../models';
// @ts-ignore
import { ChatDeleteScheduledMessageResponse } from '../models';
// @ts-ignore
import { ChatDeleteScheduledMessagedefaultResponse } from '../models';
// @ts-ignore
import { ChatDeletedefaultResponse } from '../models';
// @ts-ignore
import { ChatGetPermalinkResponse } from '../models';
// @ts-ignore
import { ChatGetPermalinkdefaultResponse } from '../models';
// @ts-ignore
import { ChatMeMessageRequest } from '../models';
// @ts-ignore
import { ChatMeMessageResponse } from '../models';
// @ts-ignore
import { ChatMeMessagedefaultResponse } from '../models';
// @ts-ignore
import { ChatPostEphemeralRequest } from '../models';
// @ts-ignore
import { ChatPostEphemeralResponse } from '../models';
// @ts-ignore
import { ChatPostEphemeraldefaultResponse } from '../models';
// @ts-ignore
import { ChatPostMessageRequest } from '../models';
// @ts-ignore
import { ChatPostMessageResponse } from '../models';
// @ts-ignore
import { ChatPostMessagedefaultResponse } from '../models';
// @ts-ignore
import { ChatScheduleMessageRequest } from '../models';
// @ts-ignore
import { ChatScheduleMessageResponse } from '../models';
// @ts-ignore
import { ChatScheduleMessagedefaultResponse } from '../models';
// @ts-ignore
import { ChatUnfurlRequest } from '../models';
// @ts-ignore
import { ChatUnfurlResponse } from '../models';
// @ts-ignore
import { ChatUnfurldefaultResponse } from '../models';
// @ts-ignore
import { ChatUpdateRequest } from '../models';
// @ts-ignore
import { ChatUpdateResponse } from '../models';
// @ts-ignore
import { ChatUpdatedefaultResponse } from '../models';
// @ts-ignore
import { ChatscheduledMessagesListResponse } from '../models';
// @ts-ignore
import { ChatscheduledMessagesListdefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a message.
         * @param {string} [token] Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {boolean} [asUser] Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
         * @param {string} [channel] Channel containing the message to be deleted.
         * @param {number} [ts] Timestamp of the message to be deleted.
         * @param {ChatDeleteRequest} [chatDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete: async (token?: string, asUser?: boolean, channel?: string, ts?: number, chatDeleteRequest?: ChatDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat.delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (ts !== undefined) {
                await addFormParam('ts', ts, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatDeleteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.delete',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatDeleteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a pending scheduled message from the queue.
         * @param {string} token Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {string} channel The channel the scheduled_message is posting to
         * @param {string} scheduledMessageId &#x60;scheduled_message_id&#x60; returned from call to chat.scheduleMessage
         * @param {boolean} [asUser] Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
         * @param {ChatDeleteScheduledMessageRequest} [chatDeleteScheduledMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledMessage: async (token: string, channel: string, scheduledMessageId: string, asUser?: boolean, chatDeleteScheduledMessageRequest?: ChatDeleteScheduledMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteScheduledMessage', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('deleteScheduledMessage', 'channel', channel)
            // verify required parameter 'scheduledMessageId' is not null or undefined
            assertParamExists('deleteScheduledMessage', 'scheduledMessageId', scheduledMessageId)
            const localVarPath = `/chat.deleteScheduledMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (scheduledMessageId !== undefined) {
                await addFormParam('scheduled_message_id', scheduledMessageId, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatDeleteScheduledMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.deleteScheduledMessage',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatDeleteScheduledMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a permalink URL for a specific extant message
         * @param {string} token Authentication token. Requires scope: &#x60;none&#x60;
         * @param {string} channel The ID of the conversation or channel containing the message
         * @param {string} messageTs A message\&#39;s &#x60;ts&#x60; value, uniquely identifying it within a channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermalink: async (token: string, channel: string, messageTs: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPermalink', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('getPermalink', 'channel', channel)
            // verify required parameter 'messageTs' is not null or undefined
            assertParamExists('getPermalink', 'messageTs', messageTs)
            const localVarPath = `/chat.getPermalink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["none"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (messageTs !== undefined) {
                localVarQueryParameter['message_ts'] = messageTs;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.getPermalink',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of scheduled messages.
         * @param {string} [token] Authentication token. Requires scope: &#x60;none&#x60;
         * @param {string} [channel] The channel of the scheduled messages
         * @param {number} [latest] A UNIX timestamp of the latest value in the time range
         * @param {number} [oldest] A UNIX timestamp of the oldest value in the time range
         * @param {number} [limit] Maximum number of original entries to return.
         * @param {string} [cursor] For pagination purposes, this is the &#x60;cursor&#x60; value returned from a previous call to &#x60;chat.scheduledmessages.list&#x60; indicating where you want to start this call from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (token?: string, channel?: string, latest?: number, oldest?: number, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat.scheduledMessages.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["none"], configuration)
            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (latest !== undefined) {
                localVarQueryParameter['latest'] = latest;
            }

            if (oldest !== undefined) {
                localVarQueryParameter['oldest'] = oldest;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.scheduledMessages.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a me message into a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {string} [channel] Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
         * @param {string} [text] Text of the message to send.
         * @param {ChatMeMessageRequest} [chatMeMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessage: async (token?: string, channel?: string, text?: string, chatMeMessageRequest?: ChatMeMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat.meMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (text !== undefined) {
                await addFormParam('text', text, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatMeMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.meMessage',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatMeMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an ephemeral message to a user in a channel.
         * @param {string} token Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {string} channel Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
         * @param {string} user &#x60;id&#x60; of the user who will receive the ephemeral message. The user should be in the channel specified by the &#x60;channel&#x60; argument.
         * @param {boolean} [asUser] Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
         * @param {string} [attachments] A JSON-based array of structured attachments, presented as a URL-encoded string.
         * @param {string} [blocks] A JSON-based array of structured blocks, presented as a URL-encoded string.
         * @param {string} [iconEmoji] Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {string} [iconUrl] URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {boolean} [linkNames] Find and link channel names and usernames.
         * @param {string} [parse] Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](https://slack.dev).
         * @param {string} [text] How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
         * @param {string} [threadTs] Provide another message\\\&#39;s &#x60;ts&#x60; value to post this message in a thread. Avoid using a reply\\\&#39;s &#x60;ts&#x60; value; use its parent\\\&#39;s value instead. Ephemeral messages in threads are only shown if there is already an active thread.
         * @param {string} [username] Set your bot\\\&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {ChatPostEphemeralRequest} [chatPostEphemeralRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEphemeral: async (token: string, channel: string, user: string, asUser?: boolean, attachments?: string, blocks?: string, iconEmoji?: string, iconUrl?: string, linkNames?: boolean, parse?: string, text?: string, threadTs?: string, username?: string, chatPostEphemeralRequest?: ChatPostEphemeralRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postEphemeral', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('postEphemeral', 'channel', channel)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('postEphemeral', 'user', user)
            const localVarPath = `/chat.postEphemeral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (attachments !== undefined) {
                await addFormParam('attachments', attachments, false, true)
            }
    
            if (blocks !== undefined) {
                await addFormParam('blocks', blocks, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (iconEmoji !== undefined) {
                await addFormParam('icon_emoji', iconEmoji, false, true)
            }
    
            if (iconUrl !== undefined) {
                await addFormParam('icon_url', iconUrl, false, true)
            }
    
            if (linkNames !== undefined) {
                await addFormParam('link_names', linkNames, false, true)
            }
    
            if (parse !== undefined) {
                await addFormParam('parse', parse, false, true)
            }
    
            if (text !== undefined) {
                await addFormParam('text', text, false, true)
            }
    
            if (threadTs !== undefined) {
                await addFormParam('thread_ts', threadTs, false, true)
            }
    
            if (user !== undefined) {
                await addFormParam('user', user, false, true)
            }
    
            if (username !== undefined) {
                await addFormParam('username', username, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatPostEphemeralRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.postEphemeral',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatPostEphemeralRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message to a channel.
         * @param {string} token Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {string} channel Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details.
         * @param {string} [asUser] Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](https://slack.dev) below.
         * @param {string} [attachments] A JSON-based array of structured attachments, presented as a URL-encoded string.
         * @param {string} [blocks] A JSON-based array of structured blocks, presented as a URL-encoded string.
         * @param {string} [iconEmoji] Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {string} [iconUrl] URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {boolean} [linkNames] Find and link channel names and usernames.
         * @param {boolean} [mrkdwn] Disable Slack markup parsing by setting to &#x60;false&#x60;. Enabled by default.
         * @param {string} [parse] Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](https://slack.dev).
         * @param {boolean} [replyBroadcast] Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
         * @param {string} [text] How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
         * @param {string} [threadTs] Provide another message\\\&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply\\\&#39;s &#x60;ts&#x60; value; use its parent instead.
         * @param {boolean} [unfurlLinks] Pass true to enable unfurling of primarily text-based content.
         * @param {boolean} [unfurlMedia] Pass false to disable unfurling of media content.
         * @param {string} [username] Set your bot\\\&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below.
         * @param {ChatPostMessageRequest} [chatPostMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage: async (token: string, channel: string, asUser?: string, attachments?: string, blocks?: string, iconEmoji?: string, iconUrl?: string, linkNames?: boolean, mrkdwn?: boolean, parse?: string, replyBroadcast?: boolean, text?: string, threadTs?: string, unfurlLinks?: boolean, unfurlMedia?: boolean, username?: string, chatPostMessageRequest?: ChatPostMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postMessage', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('postMessage', 'channel', channel)
            const localVarPath = `/chat.postMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (attachments !== undefined) {
                await addFormParam('attachments', attachments, false, true)
            }
    
            if (blocks !== undefined) {
                await addFormParam('blocks', blocks, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (iconEmoji !== undefined) {
                await addFormParam('icon_emoji', iconEmoji, false, true)
            }
    
            if (iconUrl !== undefined) {
                await addFormParam('icon_url', iconUrl, false, true)
            }
    
            if (linkNames !== undefined) {
                await addFormParam('link_names', linkNames, false, true)
            }
    
            if (mrkdwn !== undefined) {
                await addFormParam('mrkdwn', mrkdwn, false, true)
            }
    
            if (parse !== undefined) {
                await addFormParam('parse', parse, false, true)
            }
    
            if (replyBroadcast !== undefined) {
                await addFormParam('reply_broadcast', replyBroadcast, false, true)
            }
    
            if (text !== undefined) {
                await addFormParam('text', text, false, true)
            }
    
            if (threadTs !== undefined) {
                await addFormParam('thread_ts', threadTs, false, true)
            }
    
            if (unfurlLinks !== undefined) {
                await addFormParam('unfurl_links', unfurlLinks, false, true)
            }
    
            if (unfurlMedia !== undefined) {
                await addFormParam('unfurl_media', unfurlMedia, false, true)
            }
    
            if (username !== undefined) {
                await addFormParam('username', username, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatPostMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.postMessage',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatPostMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedules a message to be sent to a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {boolean} [asUser] Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
         * @param {string} [attachments] A JSON-based array of structured attachments, presented as a URL-encoded string.
         * @param {string} [blocks] A JSON-based array of structured blocks, presented as a URL-encoded string.
         * @param {string} [channel] Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details.
         * @param {boolean} [linkNames] Find and link channel names and usernames.
         * @param {string} [parse] Change how messages are treated. Defaults to &#x60;none&#x60;. See [chat.postMessage](chat.postMessage#formatting).
         * @param {string} [postAt] Unix EPOCH timestamp of time in future to send the message.
         * @param {boolean} [replyBroadcast] Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
         * @param {string} [text] How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
         * @param {number} [threadTs] Provide another message\\\&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply\\\&#39;s &#x60;ts&#x60; value; use its parent instead.
         * @param {boolean} [unfurlLinks] Pass true to enable unfurling of primarily text-based content.
         * @param {boolean} [unfurlMedia] Pass false to disable unfurling of media content.
         * @param {ChatScheduleMessageRequest} [chatScheduleMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleMessage: async (token?: string, asUser?: boolean, attachments?: string, blocks?: string, channel?: string, linkNames?: boolean, parse?: string, postAt?: string, replyBroadcast?: boolean, text?: string, threadTs?: number, unfurlLinks?: boolean, unfurlMedia?: boolean, chatScheduleMessageRequest?: ChatScheduleMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat.scheduleMessage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (attachments !== undefined) {
                await addFormParam('attachments', attachments, false, true)
            }
    
            if (blocks !== undefined) {
                await addFormParam('blocks', blocks, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (linkNames !== undefined) {
                await addFormParam('link_names', linkNames, false, true)
            }
    
            if (parse !== undefined) {
                await addFormParam('parse', parse, false, true)
            }
    
            if (postAt !== undefined) {
                await addFormParam('post_at', postAt, false, true)
            }
    
            if (replyBroadcast !== undefined) {
                await addFormParam('reply_broadcast', replyBroadcast, false, true)
            }
    
            if (text !== undefined) {
                await addFormParam('text', text, false, true)
            }
    
            if (threadTs !== undefined) {
                await addFormParam('thread_ts', threadTs, false, true)
            }
    
            if (unfurlLinks !== undefined) {
                await addFormParam('unfurl_links', unfurlLinks, false, true)
            }
    
            if (unfurlMedia !== undefined) {
                await addFormParam('unfurl_media', unfurlMedia, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatScheduleMessageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.scheduleMessage',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatScheduleMessageRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide custom unfurl behavior for user-posted URLs
         * @param {string} token Authentication token. Requires scope: &#x60;links:write&#x60;
         * @param {string} channel Channel ID of the message
         * @param {string} ts Timestamp of the message to add unfurl behavior to.
         * @param {ChatUnfurlRequest} chatUnfurlRequest 
         * @param {string} [unfurls] URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
         * @param {string} [userAuthMessage] Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
         * @param {boolean} [userAuthRequired] Set to &#x60;true&#x60; or &#x60;1&#x60; to indicate the user must install your Slack app to trigger unfurls for this domain
         * @param {string} [userAuthUrl] Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfurl: async (token: string, channel: string, ts: string, chatUnfurlRequest: ChatUnfurlRequest, unfurls?: string, userAuthMessage?: string, userAuthRequired?: boolean, userAuthUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('unfurl', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('unfurl', 'channel', channel)
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('unfurl', 'ts', ts)
            // verify required parameter 'chatUnfurlRequest' is not null or undefined
            assertParamExists('unfurl', 'chatUnfurlRequest', chatUnfurlRequest)
            const localVarPath = `/chat.unfurl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["links:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (ts !== undefined) {
                await addFormParam('ts', ts, false, true)
            }
    
            if (unfurls !== undefined) {
                await addFormParam('unfurls', unfurls, false, true)
            }
    
            if (userAuthMessage !== undefined) {
                await addFormParam('user_auth_message', userAuthMessage, false, true)
            }
    
            if (userAuthRequired !== undefined) {
                await addFormParam('user_auth_required', userAuthRequired, false, true)
            }
    
            if (userAuthUrl !== undefined) {
                await addFormParam('user_auth_url', userAuthUrl, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatUnfurlRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.unfurl',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatUnfurlRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a message.
         * @param {string} token Authentication token. Requires scope: &#x60;chat:write&#x60;
         * @param {string} channel Channel containing the message to be updated.
         * @param {string} ts Timestamp of the message to be updated.
         * @param {string} [asUser] Pass true to update the message as the authed user. [Bot users](https://slack.dev) in this context are considered authed users.
         * @param {string} [attachments] A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting &#x60;text&#x60;. If you don\\\&#39;t include this field, the message\\\&#39;s previous &#x60;attachments&#x60; will be retained. To remove previous &#x60;attachments&#x60;, include an empty array for this field.
         * @param {string} [blocks] A JSON-based array of [structured blocks](https://slack.dev), presented as a URL-encoded string. If you don\\\&#39;t include this field, the message\\\&#39;s previous &#x60;blocks&#x60; will be retained. To remove previous &#x60;blocks&#x60;, include an empty array for this field.
         * @param {string} [linkNames] Find and link channel names and usernames. Defaults to &#x60;none&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;none&#x60;.
         * @param {string} [parse] Change how messages are treated. Defaults to &#x60;client&#x60;, unlike &#x60;chat.postMessage&#x60;. Accepts either &#x60;none&#x60; or &#x60;full&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;client&#x60;.
         * @param {string} [text] New text for the message, using the [default formatting rules](https://slack.dev). It\\\&#39;s not required when presenting &#x60;blocks&#x60; or &#x60;attachments&#x60;.
         * @param {ChatUpdateRequest} [chatUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (token: string, channel: string, ts: string, asUser?: string, attachments?: string, blocks?: string, linkNames?: string, parse?: string, text?: string, chatUpdateRequest?: ChatUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('update', 'token', token)
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('update', 'channel', channel)
            // verify required parameter 'ts' is not null or undefined
            assertParamExists('update', 'ts', ts)
            const localVarPath = `/chat.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["chat:write:user", "chat:write:bot"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (asUser !== undefined) {
                await addFormParam('as_user', asUser, false, true)
            }
    
            if (attachments !== undefined) {
                await addFormParam('attachments', attachments, false, true)
            }
    
            if (blocks !== undefined) {
                await addFormParam('blocks', blocks, false, true)
            }
    
            if (channel !== undefined) {
                await addFormParam('channel', channel, false, true)
            }
    
            if (linkNames !== undefined) {
                await addFormParam('link_names', linkNames, false, true)
            }
    
            if (parse !== undefined) {
                await addFormParam('parse', parse, false, true)
            }
    
            if (text !== undefined) {
                await addFormParam('text', text, false, true)
            }
    
            if (ts !== undefined) {
                await addFormParam('ts', ts, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: chatUpdateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/chat.update',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(chatUpdateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a message.
         * @param {ChatApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete(requestParameters: ChatApiDeleteRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatDeleteResponse>> {
            const chatDeleteRequest: ChatDeleteRequest = {
                as_user: requestParameters.as_user,
                channel: requestParameters.channel,
                ts: requestParameters.ts
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete(requestParameters.token, requestParameters.asUser, requestParameters.channel, requestParameters.ts, chatDeleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a pending scheduled message from the queue.
         * @param {ChatApiDeleteScheduledMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduledMessage(requestParameters: ChatApiDeleteScheduledMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatDeleteScheduledMessageResponse>> {
            const chatDeleteScheduledMessageRequest: ChatDeleteScheduledMessageRequest = {
                as_user: requestParameters.as_user,
                channel: requestParameters.channel,
                scheduled_message_id: requestParameters.scheduled_message_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduledMessage(requestParameters.token, requestParameters.channel, requestParameters.scheduledMessageId, requestParameters.asUser, chatDeleteScheduledMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a permalink URL for a specific extant message
         * @param {ChatApiGetPermalinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermalink(requestParameters: ChatApiGetPermalinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatGetPermalinkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermalink(requestParameters.token, requestParameters.channel, requestParameters.messageTs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of scheduled messages.
         * @param {ChatApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: ChatApiListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatscheduledMessagesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.token, requestParameters.channel, requestParameters.latest, requestParameters.oldest, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share a me message into a channel.
         * @param {ChatApiMeMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meMessage(requestParameters: ChatApiMeMessageRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatMeMessageResponse>> {
            const chatMeMessageRequest: ChatMeMessageRequest = {
                channel: requestParameters.channel,
                text: requestParameters.text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.meMessage(requestParameters.token, requestParameters.channel, requestParameters.text, chatMeMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an ephemeral message to a user in a channel.
         * @param {ChatApiPostEphemeralRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEphemeral(requestParameters: ChatApiPostEphemeralRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatPostEphemeralResponse>> {
            const chatPostEphemeralRequest: ChatPostEphemeralRequest = {
                as_user: requestParameters.as_user,
                attachments: requestParameters.attachments,
                blocks: requestParameters.blocks,
                channel: requestParameters.channel,
                icon_emoji: requestParameters.icon_emoji,
                icon_url: requestParameters.icon_url,
                link_names: requestParameters.link_names,
                parse: requestParameters.parse,
                text: requestParameters.text,
                thread_ts: requestParameters.thread_ts,
                user: requestParameters.user,
                username: requestParameters.username
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEphemeral(requestParameters.token, requestParameters.channel, requestParameters.user, requestParameters.asUser, requestParameters.attachments, requestParameters.blocks, requestParameters.iconEmoji, requestParameters.iconUrl, requestParameters.linkNames, requestParameters.parse, requestParameters.text, requestParameters.threadTs, requestParameters.username, chatPostEphemeralRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends a message to a channel.
         * @param {ChatApiPostMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMessage(requestParameters: ChatApiPostMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatPostMessageResponse>> {
            const chatPostMessageRequest: ChatPostMessageRequest = {
                as_user: requestParameters.as_user,
                attachments: requestParameters.attachments,
                blocks: requestParameters.blocks,
                channel: requestParameters.channel,
                icon_emoji: requestParameters.icon_emoji,
                icon_url: requestParameters.icon_url,
                link_names: requestParameters.link_names,
                mrkdwn: requestParameters.mrkdwn,
                parse: requestParameters.parse,
                reply_broadcast: requestParameters.reply_broadcast,
                text: requestParameters.text,
                thread_ts: requestParameters.thread_ts,
                unfurl_links: requestParameters.unfurl_links,
                unfurl_media: requestParameters.unfurl_media,
                username: requestParameters.username
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMessage(requestParameters.token, requestParameters.channel, requestParameters.asUser, requestParameters.attachments, requestParameters.blocks, requestParameters.iconEmoji, requestParameters.iconUrl, requestParameters.linkNames, requestParameters.mrkdwn, requestParameters.parse, requestParameters.replyBroadcast, requestParameters.text, requestParameters.threadTs, requestParameters.unfurlLinks, requestParameters.unfurlMedia, requestParameters.username, chatPostMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedules a message to be sent to a channel.
         * @param {ChatApiScheduleMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleMessage(requestParameters: ChatApiScheduleMessageRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatScheduleMessageResponse>> {
            const chatScheduleMessageRequest: ChatScheduleMessageRequest = {
                as_user: requestParameters.as_user,
                attachments: requestParameters.attachments,
                blocks: requestParameters.blocks,
                channel: requestParameters.channel,
                link_names: requestParameters.link_names,
                parse: requestParameters.parse,
                post_at: requestParameters.post_at,
                reply_broadcast: requestParameters.reply_broadcast,
                text: requestParameters.text,
                thread_ts: requestParameters.thread_ts,
                unfurl_links: requestParameters.unfurl_links,
                unfurl_media: requestParameters.unfurl_media
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleMessage(requestParameters.token, requestParameters.asUser, requestParameters.attachments, requestParameters.blocks, requestParameters.channel, requestParameters.linkNames, requestParameters.parse, requestParameters.postAt, requestParameters.replyBroadcast, requestParameters.text, requestParameters.threadTs, requestParameters.unfurlLinks, requestParameters.unfurlMedia, chatScheduleMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide custom unfurl behavior for user-posted URLs
         * @param {ChatApiUnfurlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfurl(requestParameters: ChatApiUnfurlRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUnfurlResponse>> {
            const chatUnfurlRequest: ChatUnfurlRequest = {
                channel: requestParameters.channel,
                ts: requestParameters.ts,
                unfurls: requestParameters.unfurls,
                user_auth_message: requestParameters.user_auth_message,
                user_auth_required: requestParameters.user_auth_required,
                user_auth_url: requestParameters.user_auth_url
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfurl(requestParameters.token, requestParameters.channel, requestParameters.ts, chatUnfurlRequest, requestParameters.unfurls, requestParameters.userAuthMessage, requestParameters.userAuthRequired, requestParameters.userAuthUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a message.
         * @param {ChatApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(requestParameters: ChatApiUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUpdateResponse>> {
            const chatUpdateRequest: ChatUpdateRequest = {
                as_user: requestParameters.as_user,
                attachments: requestParameters.attachments,
                blocks: requestParameters.blocks,
                channel: requestParameters.channel,
                link_names: requestParameters.link_names,
                parse: requestParameters.parse,
                text: requestParameters.text,
                ts: requestParameters.ts
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(requestParameters.token, requestParameters.channel, requestParameters.ts, requestParameters.asUser, requestParameters.attachments, requestParameters.blocks, requestParameters.linkNames, requestParameters.parse, requestParameters.text, chatUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Deletes a message.
         * @param {ChatApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete(requestParameters: ChatApiDeleteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ChatDeleteResponse> {
            return localVarFp.delete(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a pending scheduled message from the queue.
         * @param {ChatApiDeleteScheduledMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledMessage(requestParameters: ChatApiDeleteScheduledMessageRequest, options?: AxiosRequestConfig): AxiosPromise<ChatDeleteScheduledMessageResponse> {
            return localVarFp.deleteScheduledMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a permalink URL for a specific extant message
         * @param {ChatApiGetPermalinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermalink(requestParameters: ChatApiGetPermalinkRequest, options?: AxiosRequestConfig): AxiosPromise<ChatGetPermalinkResponse> {
            return localVarFp.getPermalink(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of scheduled messages.
         * @param {ChatApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: ChatApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ChatscheduledMessagesListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a me message into a channel.
         * @param {ChatApiMeMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meMessage(requestParameters: ChatApiMeMessageRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ChatMeMessageResponse> {
            return localVarFp.meMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an ephemeral message to a user in a channel.
         * @param {ChatApiPostEphemeralRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEphemeral(requestParameters: ChatApiPostEphemeralRequest, options?: AxiosRequestConfig): AxiosPromise<ChatPostEphemeralResponse> {
            return localVarFp.postEphemeral(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message to a channel.
         * @param {ChatApiPostMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(requestParameters: ChatApiPostMessageRequest, options?: AxiosRequestConfig): AxiosPromise<ChatPostMessageResponse> {
            return localVarFp.postMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedules a message to be sent to a channel.
         * @param {ChatApiScheduleMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleMessage(requestParameters: ChatApiScheduleMessageRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ChatScheduleMessageResponse> {
            return localVarFp.scheduleMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide custom unfurl behavior for user-posted URLs
         * @param {ChatApiUnfurlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfurl(requestParameters: ChatApiUnfurlRequest, options?: AxiosRequestConfig): AxiosPromise<ChatUnfurlResponse> {
            return localVarFp.unfurl(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a message.
         * @param {ChatApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ChatApiUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<ChatUpdateResponse> {
            return localVarFp.update(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for delete operation in ChatApi.
 * @export
 * @interface ChatApiDeleteRequest
 */
export type ChatApiDeleteRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiDelete
    */
    readonly token?: string
    
    /**
    * Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
    * @type {boolean}
    * @memberof ChatApiDelete
    */
    readonly asUser?: boolean
    
    /**
    * Channel containing the message to be deleted.
    * @type {string}
    * @memberof ChatApiDelete
    */
    readonly channel?: string
    
    /**
    * Timestamp of the message to be deleted.
    * @type {number}
    * @memberof ChatApiDelete
    */
    readonly ts?: number
    
} & ChatDeleteRequest

/**
 * Request parameters for deleteScheduledMessage operation in ChatApi.
 * @export
 * @interface ChatApiDeleteScheduledMessageRequest
 */
export type ChatApiDeleteScheduledMessageRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiDeleteScheduledMessage
    */
    readonly token: string
    
    /**
    * The channel the scheduled_message is posting to
    * @type {string}
    * @memberof ChatApiDeleteScheduledMessage
    */
    readonly channel: string
    
    /**
    * `scheduled_message_id` returned from call to chat.scheduleMessage
    * @type {string}
    * @memberof ChatApiDeleteScheduledMessage
    */
    readonly scheduledMessageId: string
    
    /**
    * Pass true to delete the message as the authed user with `chat:write:user` scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with `chat:write:bot` scope.
    * @type {boolean}
    * @memberof ChatApiDeleteScheduledMessage
    */
    readonly asUser?: boolean
    
} & ChatDeleteScheduledMessageRequest

/**
 * Request parameters for getPermalink operation in ChatApi.
 * @export
 * @interface ChatApiGetPermalinkRequest
 */
export type ChatApiGetPermalinkRequest = {
    
    /**
    * Authentication token. Requires scope: `none`
    * @type {string}
    * @memberof ChatApiGetPermalink
    */
    readonly token: string
    
    /**
    * The ID of the conversation or channel containing the message
    * @type {string}
    * @memberof ChatApiGetPermalink
    */
    readonly channel: string
    
    /**
    * A message\'s `ts` value, uniquely identifying it within a channel
    * @type {string}
    * @memberof ChatApiGetPermalink
    */
    readonly messageTs: string
    
}

/**
 * Request parameters for list operation in ChatApi.
 * @export
 * @interface ChatApiListRequest
 */
export type ChatApiListRequest = {
    
    /**
    * Authentication token. Requires scope: `none`
    * @type {string}
    * @memberof ChatApiList
    */
    readonly token?: string
    
    /**
    * The channel of the scheduled messages
    * @type {string}
    * @memberof ChatApiList
    */
    readonly channel?: string
    
    /**
    * A UNIX timestamp of the latest value in the time range
    * @type {number}
    * @memberof ChatApiList
    */
    readonly latest?: number
    
    /**
    * A UNIX timestamp of the oldest value in the time range
    * @type {number}
    * @memberof ChatApiList
    */
    readonly oldest?: number
    
    /**
    * Maximum number of original entries to return.
    * @type {number}
    * @memberof ChatApiList
    */
    readonly limit?: number
    
    /**
    * For pagination purposes, this is the `cursor` value returned from a previous call to `chat.scheduledmessages.list` indicating where you want to start this call from.
    * @type {string}
    * @memberof ChatApiList
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for meMessage operation in ChatApi.
 * @export
 * @interface ChatApiMeMessageRequest
 */
export type ChatApiMeMessageRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiMeMessage
    */
    readonly token?: string
    
    /**
    * Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
    * @type {string}
    * @memberof ChatApiMeMessage
    */
    readonly channel?: string
    
    /**
    * Text of the message to send.
    * @type {string}
    * @memberof ChatApiMeMessage
    */
    readonly text?: string
    
} & ChatMeMessageRequest

/**
 * Request parameters for postEphemeral operation in ChatApi.
 * @export
 * @interface ChatApiPostEphemeralRequest
 */
export type ChatApiPostEphemeralRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly token: string
    
    /**
    * Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly channel: string
    
    /**
    * `id` of the user who will receive the ephemeral message. The user should be in the channel specified by the `channel` argument.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly user: string
    
    /**
    * Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false.
    * @type {boolean}
    * @memberof ChatApiPostEphemeral
    */
    readonly asUser?: boolean
    
    /**
    * A JSON-based array of structured attachments, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly attachments?: string
    
    /**
    * A JSON-based array of structured blocks, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly blocks?: string
    
    /**
    * Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly iconEmoji?: string
    
    /**
    * URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly iconUrl?: string
    
    /**
    * Find and link channel names and usernames.
    * @type {boolean}
    * @memberof ChatApiPostEphemeral
    */
    readonly linkNames?: boolean
    
    /**
    * Change how messages are treated. Defaults to `none`. See [below](https://slack.dev).
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly parse?: string
    
    /**
    * How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly text?: string
    
    /**
    * Provide another message\\\'s `ts` value to post this message in a thread. Avoid using a reply\\\'s `ts` value; use its parent\\\'s value instead. Ephemeral messages in threads are only shown if there is already an active thread.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly threadTs?: string
    
    /**
    * Set your bot\\\'s user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostEphemeral
    */
    readonly username?: string
    
} & ChatPostEphemeralRequest

/**
 * Request parameters for postMessage operation in ChatApi.
 * @export
 * @interface ChatApiPostMessageRequest
 */
export type ChatApiPostMessageRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly token: string
    
    /**
    * Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly channel: string
    
    /**
    * Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly asUser?: string
    
    /**
    * A JSON-based array of structured attachments, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly attachments?: string
    
    /**
    * A JSON-based array of structured blocks, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly blocks?: string
    
    /**
    * Emoji to use as the icon for this message. Overrides `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly iconEmoji?: string
    
    /**
    * URL to an image to use as the icon for this message. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly iconUrl?: string
    
    /**
    * Find and link channel names and usernames.
    * @type {boolean}
    * @memberof ChatApiPostMessage
    */
    readonly linkNames?: boolean
    
    /**
    * Disable Slack markup parsing by setting to `false`. Enabled by default.
    * @type {boolean}
    * @memberof ChatApiPostMessage
    */
    readonly mrkdwn?: boolean
    
    /**
    * Change how messages are treated. Defaults to `none`. See [below](https://slack.dev).
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly parse?: string
    
    /**
    * Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
    * @type {boolean}
    * @memberof ChatApiPostMessage
    */
    readonly replyBroadcast?: boolean
    
    /**
    * How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly text?: string
    
    /**
    * Provide another message\\\'s `ts` value to make this message a reply. Avoid using a reply\\\'s `ts` value; use its parent instead.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly threadTs?: string
    
    /**
    * Pass true to enable unfurling of primarily text-based content.
    * @type {boolean}
    * @memberof ChatApiPostMessage
    */
    readonly unfurlLinks?: boolean
    
    /**
    * Pass false to disable unfurling of media content.
    * @type {boolean}
    * @memberof ChatApiPostMessage
    */
    readonly unfurlMedia?: boolean
    
    /**
    * Set your bot\\\'s user name. Must be used in conjunction with `as_user` set to false, otherwise ignored. See [authorship](https://slack.dev) below.
    * @type {string}
    * @memberof ChatApiPostMessage
    */
    readonly username?: string
    
} & ChatPostMessageRequest

/**
 * Request parameters for scheduleMessage operation in ChatApi.
 * @export
 * @interface ChatApiScheduleMessageRequest
 */
export type ChatApiScheduleMessageRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly token?: string
    
    /**
    * Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
    * @type {boolean}
    * @memberof ChatApiScheduleMessage
    */
    readonly asUser?: boolean
    
    /**
    * A JSON-based array of structured attachments, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly attachments?: string
    
    /**
    * A JSON-based array of structured blocks, presented as a URL-encoded string.
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly blocks?: string
    
    /**
    * Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details.
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly channel?: string
    
    /**
    * Find and link channel names and usernames.
    * @type {boolean}
    * @memberof ChatApiScheduleMessage
    */
    readonly linkNames?: boolean
    
    /**
    * Change how messages are treated. Defaults to `none`. See [chat.postMessage](chat.postMessage#formatting).
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly parse?: string
    
    /**
    * Unix EPOCH timestamp of time in future to send the message.
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly postAt?: string
    
    /**
    * Used in conjunction with `thread_ts` and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to `false`.
    * @type {boolean}
    * @memberof ChatApiScheduleMessage
    */
    readonly replyBroadcast?: boolean
    
    /**
    * How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail.
    * @type {string}
    * @memberof ChatApiScheduleMessage
    */
    readonly text?: string
    
    /**
    * Provide another message\\\'s `ts` value to make this message a reply. Avoid using a reply\\\'s `ts` value; use its parent instead.
    * @type {number}
    * @memberof ChatApiScheduleMessage
    */
    readonly threadTs?: number
    
    /**
    * Pass true to enable unfurling of primarily text-based content.
    * @type {boolean}
    * @memberof ChatApiScheduleMessage
    */
    readonly unfurlLinks?: boolean
    
    /**
    * Pass false to disable unfurling of media content.
    * @type {boolean}
    * @memberof ChatApiScheduleMessage
    */
    readonly unfurlMedia?: boolean
    
} & ChatScheduleMessageRequest

/**
 * Request parameters for unfurl operation in ChatApi.
 * @export
 * @interface ChatApiUnfurlRequest
 */
export type ChatApiUnfurlRequest = {
    
    /**
    * Authentication token. Requires scope: `links:write`
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly token: string
    
    /**
    * Channel ID of the message
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly channel: string
    
    /**
    * Timestamp of the message to add unfurl behavior to.
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly ts: string
    
    /**
    * URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments.
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly unfurls?: string
    
    /**
    * Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly userAuthMessage?: string
    
    /**
    * Set to `true` or `1` to indicate the user must install your Slack app to trigger unfurls for this domain
    * @type {boolean}
    * @memberof ChatApiUnfurl
    */
    readonly userAuthRequired?: boolean
    
    /**
    * Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
    * @type {string}
    * @memberof ChatApiUnfurl
    */
    readonly userAuthUrl?: string
    
} & ChatUnfurlRequest

/**
 * Request parameters for update operation in ChatApi.
 * @export
 * @interface ChatApiUpdateRequest
 */
export type ChatApiUpdateRequest = {
    
    /**
    * Authentication token. Requires scope: `chat:write`
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly token: string
    
    /**
    * Channel containing the message to be updated.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly channel: string
    
    /**
    * Timestamp of the message to be updated.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly ts: string
    
    /**
    * Pass true to update the message as the authed user. [Bot users](https://slack.dev) in this context are considered authed users.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly asUser?: string
    
    /**
    * A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting `text`. If you don\\\'t include this field, the message\\\'s previous `attachments` will be retained. To remove previous `attachments`, include an empty array for this field.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly attachments?: string
    
    /**
    * A JSON-based array of [structured blocks](https://slack.dev), presented as a URL-encoded string. If you don\\\'t include this field, the message\\\'s previous `blocks` will be retained. To remove previous `blocks`, include an empty array for this field.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly blocks?: string
    
    /**
    * Find and link channel names and usernames. Defaults to `none`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `none`.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly linkNames?: string
    
    /**
    * Change how messages are treated. Defaults to `client`, unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, `client`.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly parse?: string
    
    /**
    * New text for the message, using the [default formatting rules](https://slack.dev). It\\\'s not required when presenting `blocks` or `attachments`.
    * @type {string}
    * @memberof ChatApiUpdate
    */
    readonly text?: string
    
} & ChatUpdateRequest

/**
 * ChatApiGenerated - object-oriented interface
 * @export
 * @class ChatApiGenerated
 * @extends {BaseAPI}
 */
export class ChatApiGenerated extends BaseAPI {
    /**
     * Deletes a message.
     * @param {ChatApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public delete(requestParameters: ChatApiDeleteRequest = {}, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).delete(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a pending scheduled message from the queue.
     * @param {ChatApiDeleteScheduledMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public deleteScheduledMessage(requestParameters: ChatApiDeleteScheduledMessageRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteScheduledMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a permalink URL for a specific extant message
     * @param {ChatApiGetPermalinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public getPermalink(requestParameters: ChatApiGetPermalinkRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).getPermalink(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of scheduled messages.
     * @param {ChatApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public list(requestParameters: ChatApiListRequest = {}, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share a me message into a channel.
     * @param {ChatApiMeMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public meMessage(requestParameters: ChatApiMeMessageRequest = {}, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).meMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an ephemeral message to a user in a channel.
     * @param {ChatApiPostEphemeralRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public postEphemeral(requestParameters: ChatApiPostEphemeralRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).postEphemeral(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message to a channel.
     * @param {ChatApiPostMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public postMessage(requestParameters: ChatApiPostMessageRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).postMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedules a message to be sent to a channel.
     * @param {ChatApiScheduleMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public scheduleMessage(requestParameters: ChatApiScheduleMessageRequest = {}, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).scheduleMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide custom unfurl behavior for user-posted URLs
     * @param {ChatApiUnfurlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public unfurl(requestParameters: ChatApiUnfurlRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).unfurl(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a message.
     * @param {ChatApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiGenerated
     */
    public update(requestParameters: ChatApiUpdateRequest, options?: AxiosRequestConfig) {
        return ChatApiFp(this.configuration).update(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
