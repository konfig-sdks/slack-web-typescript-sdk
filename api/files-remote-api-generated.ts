/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FilesremoteAddFromRemoteRequest } from '../models';
// @ts-ignore
import { FilesremoteAddFromRemoteResponse } from '../models';
// @ts-ignore
import { FilesremoteAddFromRemotedefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteDeleteFileRequest } from '../models';
// @ts-ignore
import { FilesremoteDeleteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteDeleteFiledefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteGetInfoResponse } from '../models';
// @ts-ignore
import { FilesremoteGetInfodefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteListRemoteFilesResponse } from '../models';
// @ts-ignore
import { FilesremoteListRemoteFilesdefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteShareRemoteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteShareRemoteFiledefaultResponse } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFileRequest } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFileResponse } from '../models';
// @ts-ignore
import { FilesremoteUpdateRemoteFiledefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * FilesRemoteApi - axios parameter creator
 * @export
 */
export const FilesRemoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a file from a remote service
         * @param {string} [title] Title of the file being shared.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [externalUrl] URL of the remote file.
         * @param {string} [filetype] type of file
         * @param {string} [indexableFileContents] A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
         * @param {string} [previewImage] Preview of the document via &#x60;multipart/form-data&#x60;.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteAddFromRemoteRequest} [filesremoteAddFromRemoteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFromRemote: async (title?: string, externalId?: string, externalUrl?: string, filetype?: string, indexableFileContents?: string, previewImage?: string, token?: string, filesremoteAddFromRemoteRequest?: FilesremoteAddFromRemoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (externalUrl !== undefined) {
                await addFormParam('external_url', externalUrl, false, true)
            }
    
            if (filetype !== undefined) {
                await addFormParam('filetype', filetype, false, true)
            }
    
            if (indexableFileContents !== undefined) {
                await addFormParam('indexable_file_contents', indexableFileContents, false, true)
            }
    
            if (previewImage !== undefined) {
                await addFormParam('preview_image', previewImage, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteAddFromRemoteRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.add',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteAddFromRemoteRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a remote file.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteDeleteFileRequest} [filesremoteDeleteFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (externalId?: string, file?: string, token?: string, filesremoteDeleteFileRequest?: FilesremoteDeleteFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteDeleteFileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.remove',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteDeleteFileRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:read&#x60;
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (token?: string, file?: string, externalId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:read&#x60;
         * @param {string} [channel] Filter files appearing in a specific channel, indicated by its ID.
         * @param {number} [tsFrom] Filter files created after this timestamp (inclusive).
         * @param {number} [tsTo] Filter files created before this timestamp (inclusive).
         * @param {number} [limit] The maximum number of items to return.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoteFiles: async (token?: string, channel?: string, tsFrom?: number, tsTo?: number, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (tsFrom !== undefined) {
                localVarQueryParameter['ts_from'] = tsFrom;
            }

            if (tsTo !== undefined) {
                localVarQueryParameter['ts_to'] = tsTo;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a remote file into a channel.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:share&#x60;
         * @param {string} [file] Specify a file registered with Slack by providing its ID. Either this field or &#x60;external_id&#x60; or both are required.
         * @param {string} [externalId] The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or &#x60;file&#x60; or both are required.
         * @param {string} [channels] Comma-separated list of channel IDs where the file will be shared.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRemoteFile: async (token?: string, file?: string, externalId?: string, channels?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:share"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (channels !== undefined) {
                localVarQueryParameter['channels'] = channels;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.share',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing remote file.
         * @param {string} [title] Title of the file being shared.
         * @param {string} [externalId] Creator defined GUID for the file.
         * @param {string} [externalUrl] URL of the remote file.
         * @param {string} [file] Specify a file by providing its ID.
         * @param {string} [filetype] type of file
         * @param {string} [indexableFileContents] File containing contents that can be used to improve searchability for the remote file.
         * @param {string} [previewImage] Preview of the document via &#x60;multipart/form-data&#x60;.
         * @param {string} [token] Authentication token. Requires scope: &#x60;remote_files:write&#x60;
         * @param {FilesremoteUpdateRemoteFileRequest} [filesremoteUpdateRemoteFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteFile: async (title?: string, externalId?: string, externalUrl?: string, file?: string, filetype?: string, indexableFileContents?: string, previewImage?: string, token?: string, filesremoteUpdateRemoteFileRequest?: FilesremoteUpdateRemoteFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files.remote.update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["remote_files:write"], configuration)

            if (title !== undefined) {
                await addFormParam('title', title, false, true)
            }
    
            if (externalId !== undefined) {
                await addFormParam('external_id', externalId, false, true)
            }
    
            if (externalUrl !== undefined) {
                await addFormParam('external_url', externalUrl, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, false, true)
            }
    
            if (filetype !== undefined) {
                await addFormParam('filetype', filetype, false, true)
            }
    
            if (indexableFileContents !== undefined) {
                await addFormParam('indexable_file_contents', indexableFileContents, false, true)
            }
    
            if (previewImage !== undefined) {
                await addFormParam('preview_image', previewImage, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: filesremoteUpdateRemoteFileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files.remote.update',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(filesremoteUpdateRemoteFileRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesRemoteApi - functional programming interface
 * @export
 */
export const FilesRemoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesRemoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a file from a remote service
         * @param {FilesRemoteApiAddFromRemoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFromRemote(requestParameters: FilesRemoteApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteAddFromRemoteResponse>> {
            const filesremoteAddFromRemoteRequest: FilesremoteAddFromRemoteRequest = {
                title: requestParameters.title,
                external_id: requestParameters.external_id,
                external_url: requestParameters.external_url,
                filetype: requestParameters.filetype,
                indexable_file_contents: requestParameters.indexable_file_contents,
                preview_image: requestParameters.preview_image,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFromRemote(requestParameters.title, requestParameters.externalId, requestParameters.externalUrl, requestParameters.filetype, requestParameters.indexableFileContents, requestParameters.previewImage, requestParameters.token, filesremoteAddFromRemoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a remote file.
         * @param {FilesRemoteApiDeleteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(requestParameters: FilesRemoteApiDeleteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteDeleteFileResponse>> {
            const filesremoteDeleteFileRequest: FilesremoteDeleteFileRequest = {
                external_id: requestParameters.external_id,
                file: requestParameters.file,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(requestParameters.externalId, requestParameters.file, requestParameters.token, filesremoteDeleteFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesRemoteApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(requestParameters: FilesRemoteApiGetInfoRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteGetInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(requestParameters.token, requestParameters.file, requestParameters.externalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesRemoteApiListRemoteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRemoteFiles(requestParameters: FilesRemoteApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteListRemoteFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRemoteFiles(requestParameters.token, requestParameters.channel, requestParameters.tsFrom, requestParameters.tsTo, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share a remote file into a channel.
         * @param {FilesRemoteApiShareRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareRemoteFile(requestParameters: FilesRemoteApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteShareRemoteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareRemoteFile(requestParameters.token, requestParameters.file, requestParameters.externalId, requestParameters.channels, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an existing remote file.
         * @param {FilesRemoteApiUpdateRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRemoteFile(requestParameters: FilesRemoteApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesremoteUpdateRemoteFileResponse>> {
            const filesremoteUpdateRemoteFileRequest: FilesremoteUpdateRemoteFileRequest = {
                title: requestParameters.title,
                external_id: requestParameters.external_id,
                external_url: requestParameters.external_url,
                file: requestParameters.file,
                filetype: requestParameters.filetype,
                indexable_file_contents: requestParameters.indexable_file_contents,
                preview_image: requestParameters.preview_image,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRemoteFile(requestParameters.title, requestParameters.externalId, requestParameters.externalUrl, requestParameters.file, requestParameters.filetype, requestParameters.indexableFileContents, requestParameters.previewImage, requestParameters.token, filesremoteUpdateRemoteFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesRemoteApi - factory interface
 * @export
 */
export const FilesRemoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesRemoteApiFp(configuration)
    return {
        /**
         * Adds a file from a remote service
         * @param {FilesRemoteApiAddFromRemoteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFromRemote(requestParameters: FilesRemoteApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteAddFromRemoteResponse> {
            return localVarFp.addFromRemote(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a remote file.
         * @param {FilesRemoteApiDeleteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(requestParameters: FilesRemoteApiDeleteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteDeleteFileResponse> {
            return localVarFp.deleteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesRemoteApiGetInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(requestParameters: FilesRemoteApiGetInfoRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteGetInfoResponse> {
            return localVarFp.getInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a remote file added to Slack
         * @param {FilesRemoteApiListRemoteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoteFiles(requestParameters: FilesRemoteApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteListRemoteFilesResponse> {
            return localVarFp.listRemoteFiles(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a remote file into a channel.
         * @param {FilesRemoteApiShareRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRemoteFile(requestParameters: FilesRemoteApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteShareRemoteFileResponse> {
            return localVarFp.shareRemoteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing remote file.
         * @param {FilesRemoteApiUpdateRemoteFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemoteFile(requestParameters: FilesRemoteApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FilesremoteUpdateRemoteFileResponse> {
            return localVarFp.updateRemoteFile(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFromRemote operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiAddFromRemoteRequest
 */
export type FilesRemoteApiAddFromRemoteRequest = {
    
    /**
    * Title of the file being shared.
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly title?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly externalId?: string
    
    /**
    * URL of the remote file.
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly externalUrl?: string
    
    /**
    * type of file
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly filetype?: string
    
    /**
    * A text file (txt, pdf, doc, etc.) containing textual search terms that are used to improve discovery of the remote file.
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly indexableFileContents?: string
    
    /**
    * Preview of the document via `multipart/form-data`.
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly previewImage?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesRemoteApiAddFromRemote
    */
    readonly token?: string
    
} & FilesremoteAddFromRemoteRequest

/**
 * Request parameters for deleteFile operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiDeleteFileRequest
 */
export type FilesRemoteApiDeleteFileRequest = {
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesRemoteApiDeleteFile
    */
    readonly externalId?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesRemoteApiDeleteFile
    */
    readonly file?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesRemoteApiDeleteFile
    */
    readonly token?: string
    
} & FilesremoteDeleteFileRequest

/**
 * Request parameters for getInfo operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiGetInfoRequest
 */
export type FilesRemoteApiGetInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:read`
    * @type {string}
    * @memberof FilesRemoteApiGetInfo
    */
    readonly token?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesRemoteApiGetInfo
    */
    readonly file?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesRemoteApiGetInfo
    */
    readonly externalId?: string
    
}

/**
 * Request parameters for listRemoteFiles operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiListRemoteFilesRequest
 */
export type FilesRemoteApiListRemoteFilesRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:read`
    * @type {string}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly token?: string
    
    /**
    * Filter files appearing in a specific channel, indicated by its ID.
    * @type {string}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly channel?: string
    
    /**
    * Filter files created after this timestamp (inclusive).
    * @type {number}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly tsFrom?: number
    
    /**
    * Filter files created before this timestamp (inclusive).
    * @type {number}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly tsTo?: number
    
    /**
    * The maximum number of items to return.
    * @type {number}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof FilesRemoteApiListRemoteFiles
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for shareRemoteFile operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiShareRemoteFileRequest
 */
export type FilesRemoteApiShareRemoteFileRequest = {
    
    /**
    * Authentication token. Requires scope: `remote_files:share`
    * @type {string}
    * @memberof FilesRemoteApiShareRemoteFile
    */
    readonly token?: string
    
    /**
    * Specify a file registered with Slack by providing its ID. Either this field or `external_id` or both are required.
    * @type {string}
    * @memberof FilesRemoteApiShareRemoteFile
    */
    readonly file?: string
    
    /**
    * The globally unique identifier (GUID) for the file, as set by the app registering the file with Slack.  Either this field or `file` or both are required.
    * @type {string}
    * @memberof FilesRemoteApiShareRemoteFile
    */
    readonly externalId?: string
    
    /**
    * Comma-separated list of channel IDs where the file will be shared.
    * @type {string}
    * @memberof FilesRemoteApiShareRemoteFile
    */
    readonly channels?: string
    
}

/**
 * Request parameters for updateRemoteFile operation in FilesRemoteApi.
 * @export
 * @interface FilesRemoteApiUpdateRemoteFileRequest
 */
export type FilesRemoteApiUpdateRemoteFileRequest = {
    
    /**
    * Title of the file being shared.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly title?: string
    
    /**
    * Creator defined GUID for the file.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly externalId?: string
    
    /**
    * URL of the remote file.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly externalUrl?: string
    
    /**
    * Specify a file by providing its ID.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly file?: string
    
    /**
    * type of file
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly filetype?: string
    
    /**
    * File containing contents that can be used to improve searchability for the remote file.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly indexableFileContents?: string
    
    /**
    * Preview of the document via `multipart/form-data`.
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly previewImage?: string
    
    /**
    * Authentication token. Requires scope: `remote_files:write`
    * @type {string}
    * @memberof FilesRemoteApiUpdateRemoteFile
    */
    readonly token?: string
    
} & FilesremoteUpdateRemoteFileRequest

/**
 * FilesRemoteApiGenerated - object-oriented interface
 * @export
 * @class FilesRemoteApiGenerated
 * @extends {BaseAPI}
 */
export class FilesRemoteApiGenerated extends BaseAPI {
    /**
     * Adds a file from a remote service
     * @param {FilesRemoteApiAddFromRemoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public addFromRemote(requestParameters: FilesRemoteApiAddFromRemoteRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).addFromRemote(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a remote file.
     * @param {FilesRemoteApiDeleteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public deleteFile(requestParameters: FilesRemoteApiDeleteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).deleteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a remote file added to Slack
     * @param {FilesRemoteApiGetInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public getInfo(requestParameters: FilesRemoteApiGetInfoRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).getInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a remote file added to Slack
     * @param {FilesRemoteApiListRemoteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public listRemoteFiles(requestParameters: FilesRemoteApiListRemoteFilesRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).listRemoteFiles(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share a remote file into a channel.
     * @param {FilesRemoteApiShareRemoteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public shareRemoteFile(requestParameters: FilesRemoteApiShareRemoteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).shareRemoteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing remote file.
     * @param {FilesRemoteApiUpdateRemoteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesRemoteApiGenerated
     */
    public updateRemoteFile(requestParameters: FilesRemoteApiUpdateRemoteFileRequest = {}, options?: AxiosRequestConfig) {
        return FilesRemoteApiFp(this.configuration).updateRemoteFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
