/* tslint:disable */
/* eslint-disable */
/*
Slack Web API

One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

The version of the OpenAPI document: 1.7.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { UsersConversationsResponse } from '../models';
// @ts-ignore
import { UsersConversationsdefaultResponse } from '../models';
// @ts-ignore
import { UsersDeletePhotoRequest } from '../models';
// @ts-ignore
import { UsersDeletePhotoResponse } from '../models';
// @ts-ignore
import { UsersDeletePhotodefaultResponse } from '../models';
// @ts-ignore
import { UsersGetPresenceResponse } from '../models';
// @ts-ignore
import { UsersGetPresencedefaultResponse } from '../models';
// @ts-ignore
import { UsersIdentityResponseInner } from '../models';
// @ts-ignore
import { UsersIdentitydefaultResponse } from '../models';
// @ts-ignore
import { UsersInfoResponse } from '../models';
// @ts-ignore
import { UsersInfodefaultResponse } from '../models';
// @ts-ignore
import { UsersListResponse } from '../models';
// @ts-ignore
import { UsersListdefaultResponse } from '../models';
// @ts-ignore
import { UsersLookupByEmailResponse } from '../models';
// @ts-ignore
import { UsersLookupByEmaildefaultResponse } from '../models';
// @ts-ignore
import { UsersSetActiveResponse } from '../models';
// @ts-ignore
import { UsersSetActivedefaultResponse } from '../models';
// @ts-ignore
import { UsersSetPhotoRequest } from '../models';
// @ts-ignore
import { UsersSetPhotoResponse } from '../models';
// @ts-ignore
import { UsersSetPhotodefaultResponse } from '../models';
// @ts-ignore
import { UsersSetPresenceRequest } from '../models';
// @ts-ignore
import { UsersSetPresenceResponse } from '../models';
// @ts-ignore
import { UsersSetPresencedefaultResponse } from '../models';
// @ts-ignore
import { UsersprofileGetProfileInfoResponse } from '../models';
// @ts-ignore
import { UsersprofileGetProfileInfodefaultResponse } from '../models';
// @ts-ignore
import { UsersprofileSetProfileInfoRequest } from '../models';
// @ts-ignore
import { UsersprofileSetProfileInfoResponse } from '../models';
// @ts-ignore
import { UsersprofileSetProfileInfodefaultResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List conversations the calling user may access.
         * @param {string} [token] Authentication token. Requires scope: &#x60;conversations:read&#x60;
         * @param {string} [user] Browse conversations by a specific user ID\&#39;s membership. Non-public channels are restricted to those where the calling user shares membership.
         * @param {string} [types] Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60;
         * @param {boolean} [excludeArchived] Set to &#x60;true&#x60; to exclude archived channels from the list
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\&#39;t been reached. Must be an integer no larger than 1000.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversations: async (token?: string, user?: string, types?: string, excludeArchived?: boolean, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users.conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["channels:read", "groups:read", "im:read", "mpim:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            if (excludeArchived !== undefined) {
                localVarQueryParameter['exclude_archived'] = excludeArchived;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.conversations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the user profile photo
         * @param {string} token Authentication token. Requires scope: &#x60;users.profile:write&#x60;
         * @param {UsersDeletePhotoRequest} usersDeletePhotoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto: async (token: string, usersDeletePhotoRequest: UsersDeletePhotoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deletePhoto', 'token', token)
            // verify required parameter 'usersDeletePhotoRequest' is not null or undefined
            assertParamExists('deletePhoto', 'usersDeletePhotoRequest', usersDeletePhotoRequest)
            const localVarPath = `/users.deletePhoto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users.profile:write"], configuration)

            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersDeletePhotoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.deletePhoto',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersDeletePhotoRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user presence information.
         * @param {string} token Authentication token. Requires scope: &#x60;users:read&#x60;
         * @param {string} [user] User to get presence info on. Defaults to the authed user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresence: async (token: string, user?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPresence', 'token', token)
            const localVarPath = `/users.getPresence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.getPresence',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a user\'s profile information.
         * @param {string} token Authentication token. Requires scope: &#x60;users.profile:read&#x60;
         * @param {boolean} [includeLabels] Include labels for each ID in custom profile fields
         * @param {string} [user] User to retrieve profile info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfo: async (token: string, includeLabels?: boolean, user?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getProfileInfo', 'token', token)
            const localVarPath = `/users.profile.get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users.profile:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (includeLabels !== undefined) {
                localVarQueryParameter['include_labels'] = includeLabels;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.profile.get',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user\'s identity.
         * @param {string} [token] Authentication token. Requires scope: &#x60;identity.basic&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identity: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users.identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["identity.basic"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.identity',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets information about a user.
         * @param {string} token Authentication token. Requires scope: &#x60;users:read&#x60;
         * @param {boolean} [includeLocale] Set this to &#x60;true&#x60; to receive the locale for this user. Defaults to &#x60;false&#x60;
         * @param {string} [user] User to get info on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (token: string, includeLocale?: boolean, user?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('info', 'token', token)
            const localVarPath = `/users.info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (includeLocale !== undefined) {
                localVarQueryParameter['include_locale'] = includeLocale;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.info',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all users in a Slack team.
         * @param {string} [token] Authentication token. Requires scope: &#x60;users:read&#x60;
         * @param {number} [limit] The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\&#39;t been reached. Providing no &#x60;limit&#x60; value will result in Slack attempting to deliver you the entire result set. If the collection is too large you may experience &#x60;limit_required&#x60; or HTTP 500 errors.
         * @param {string} [cursor] Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request\&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail.
         * @param {boolean} [includeLocale] Set this to &#x60;true&#x60; to receive the locale for users. Defaults to &#x60;false&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (token?: string, limit?: number, cursor?: string, includeLocale?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users.list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:read"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (includeLocale !== undefined) {
                localVarQueryParameter['include_locale'] = includeLocale;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a user with an email address.
         * @param {string} token Authentication token. Requires scope: &#x60;users:read.email&#x60;
         * @param {string} email An email address belonging to a user in the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByEmail: async (token: string, email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('lookupByEmail', 'token', token)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('lookupByEmail', 'email', email)
            const localVarPath = `/users.lookupByEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:read.email"], configuration)
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.lookupByEmail',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marked a user as active. Deprecated and non-functional.
         * @param {string} token Authentication token. Requires scope: &#x60;users:write&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActive: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setActive', 'token', token)
            const localVarPath = `/users.setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.setActive',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the user profile photo
         * @param {string} token Authentication token. Requires scope: &#x60;users.profile:write&#x60;
         * @param {UsersSetPhotoRequest} usersSetPhotoRequest 
         * @param {string} [cropW] Width/height of crop box (always square)
         * @param {string} [cropX] X coordinate of top-left corner of crop box
         * @param {string} [cropY] Y coordinate of top-left corner of crop box
         * @param {string} [image] File contents via &#x60;multipart/form-data&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhoto: async (token: string, usersSetPhotoRequest: UsersSetPhotoRequest, cropW?: string, cropX?: string, cropY?: string, image?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setPhoto', 'token', token)
            // verify required parameter 'usersSetPhotoRequest' is not null or undefined
            assertParamExists('setPhoto', 'usersSetPhotoRequest', usersSetPhotoRequest)
            const localVarPath = `/users.setPhoto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users.profile:write"], configuration)

            if (cropW !== undefined) {
                await addFormParam('crop_w', cropW, false, true)
            }
    
            if (cropX !== undefined) {
                await addFormParam('crop_x', cropX, false, true)
            }
    
            if (cropY !== undefined) {
                await addFormParam('crop_y', cropY, false, true)
            }
    
            if (image !== undefined) {
                await addFormParam('image', image, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersSetPhotoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.setPhoto',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersSetPhotoRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually sets user presence.
         * @param {string} token Authentication token. Requires scope: &#x60;users:write&#x60;
         * @param {string} presence Either &#x60;auto&#x60; or &#x60;away&#x60;
         * @param {UsersSetPresenceRequest} usersSetPresenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPresence: async (token: string, presence: string, usersSetPresenceRequest: UsersSetPresenceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setPresence', 'token', token)
            // verify required parameter 'presence' is not null or undefined
            assertParamExists('setPresence', 'presence', presence)
            // verify required parameter 'usersSetPresenceRequest' is not null or undefined
            assertParamExists('setPresence', 'usersSetPresenceRequest', usersSetPresenceRequest)
            const localVarPath = `/users.setPresence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (presence !== undefined) {
                await addFormParam('presence', presence, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersSetPresenceRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.setPresence',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersSetPresenceRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the profile information for a user.
         * @param {string} token Authentication token. Requires scope: &#x60;users.profile:write&#x60;
         * @param {string} [name] Name of a single key to set. Usable only if &#x60;profile&#x60; is not passed.
         * @param {string} [profile] Collection of key:value pairs presented as a URL-encoded JSON hash. At most 50 fields may be set. Each field name is limited to 255 characters.
         * @param {string} [user] ID of user to change. This argument may only be specified by team admins on paid teams.
         * @param {string} [value] Value to set a single key to. Usable only if &#x60;profile&#x60; is not passed.
         * @param {UsersprofileSetProfileInfoRequest} [usersprofileSetProfileInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfileInfo: async (token: string, name?: string, profile?: string, user?: string, value?: string, usersprofileSetProfileInfoRequest?: UsersprofileSetProfileInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('setProfileInfo', 'token', token)
            const localVarPath = `/users.profile.set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication slackAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "slackAuth", ["users.profile:write"], configuration)
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }


            if (name !== undefined) {
                await addFormParam('name', name, false, true)
            }
    
            if (profile !== undefined) {
                await addFormParam('profile', profile, false, true)
            }
    
            if (user !== undefined) {
                await addFormParam('user', user, false, true)
            }
    
            if (value !== undefined) {
                await addFormParam('value', value, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: usersprofileSetProfileInfoRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users.profile.set',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(usersprofileSetProfileInfoRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * List conversations the calling user may access.
         * @param {UsersApiConversationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversations(requestParameters: UsersApiConversationsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersConversationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversations(requestParameters.token, requestParameters.user, requestParameters.types, requestParameters.excludeArchived, requestParameters.limit, requestParameters.cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the user profile photo
         * @param {UsersApiDeletePhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoto(requestParameters: UsersApiDeletePhotoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersDeletePhotoResponse>> {
            const usersDeletePhotoRequest: UsersDeletePhotoRequest = {
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhoto(requestParameters.token, usersDeletePhotoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets user presence information.
         * @param {UsersApiGetPresenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresence(requestParameters: UsersApiGetPresenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGetPresenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresence(requestParameters.token, requestParameters.user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a user\'s profile information.
         * @param {UsersApiGetProfileInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInfo(requestParameters: UsersApiGetProfileInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersprofileGetProfileInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileInfo(requestParameters.token, requestParameters.includeLabels, requestParameters.user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user\'s identity.
         * @param {UsersApiIdentityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identity(requestParameters: UsersApiIdentityRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsersIdentityResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identity(requestParameters.token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets information about a user.
         * @param {UsersApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(requestParameters: UsersApiInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(requestParameters.token, requestParameters.includeLocale, requestParameters.user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all users in a Slack team.
         * @param {UsersApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: UsersApiListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.token, requestParameters.limit, requestParameters.cursor, requestParameters.includeLocale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find a user with an email address.
         * @param {UsersApiLookupByEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupByEmail(requestParameters: UsersApiLookupByEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLookupByEmailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupByEmail(requestParameters.token, requestParameters.email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marked a user as active. Deprecated and non-functional.
         * @param {UsersApiSetActiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setActive(requestParameters: UsersApiSetActiveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersSetActiveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setActive(requestParameters.token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the user profile photo
         * @param {UsersApiSetPhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPhoto(requestParameters: UsersApiSetPhotoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersSetPhotoResponse>> {
            const usersSetPhotoRequest: UsersSetPhotoRequest = {
                crop_w: requestParameters.crop_w,
                crop_x: requestParameters.crop_x,
                crop_y: requestParameters.crop_y,
                image: requestParameters.image,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPhoto(requestParameters.token, usersSetPhotoRequest, requestParameters.cropW, requestParameters.cropX, requestParameters.cropY, requestParameters.image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Manually sets user presence.
         * @param {UsersApiSetPresenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPresence(requestParameters: UsersApiSetPresenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersSetPresenceResponse>> {
            const usersSetPresenceRequest: UsersSetPresenceRequest = {
                presence: requestParameters.presence
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPresence(requestParameters.token, requestParameters.presence, usersSetPresenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the profile information for a user.
         * @param {UsersApiSetProfileInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProfileInfo(requestParameters: UsersApiSetProfileInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersprofileSetProfileInfoResponse>> {
            const usersprofileSetProfileInfoRequest: UsersprofileSetProfileInfoRequest = {
                name: requestParameters.name,
                profile: requestParameters.profile,
                user: requestParameters.user,
                value: requestParameters.value
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProfileInfo(requestParameters.token, requestParameters.name, requestParameters.profile, requestParameters.user, requestParameters.value, usersprofileSetProfileInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * List conversations the calling user may access.
         * @param {UsersApiConversationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversations(requestParameters: UsersApiConversationsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<UsersConversationsResponse> {
            return localVarFp.conversations(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the user profile photo
         * @param {UsersApiDeletePhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto(requestParameters: UsersApiDeletePhotoRequest, options?: AxiosRequestConfig): AxiosPromise<UsersDeletePhotoResponse> {
            return localVarFp.deletePhoto(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets user presence information.
         * @param {UsersApiGetPresenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresence(requestParameters: UsersApiGetPresenceRequest, options?: AxiosRequestConfig): AxiosPromise<UsersGetPresenceResponse> {
            return localVarFp.getPresence(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a user\'s profile information.
         * @param {UsersApiGetProfileInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfo(requestParameters: UsersApiGetProfileInfoRequest, options?: AxiosRequestConfig): AxiosPromise<UsersprofileGetProfileInfoResponse> {
            return localVarFp.getProfileInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user\'s identity.
         * @param {UsersApiIdentityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identity(requestParameters: UsersApiIdentityRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<UsersIdentityResponseInner>> {
            return localVarFp.identity(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets information about a user.
         * @param {UsersApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(requestParameters: UsersApiInfoRequest, options?: AxiosRequestConfig): AxiosPromise<UsersInfoResponse> {
            return localVarFp.info(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all users in a Slack team.
         * @param {UsersApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: UsersApiListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<UsersListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a user with an email address.
         * @param {UsersApiLookupByEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupByEmail(requestParameters: UsersApiLookupByEmailRequest, options?: AxiosRequestConfig): AxiosPromise<UsersLookupByEmailResponse> {
            return localVarFp.lookupByEmail(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Marked a user as active. Deprecated and non-functional.
         * @param {UsersApiSetActiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActive(requestParameters: UsersApiSetActiveRequest, options?: AxiosRequestConfig): AxiosPromise<UsersSetActiveResponse> {
            return localVarFp.setActive(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the user profile photo
         * @param {UsersApiSetPhotoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhoto(requestParameters: UsersApiSetPhotoRequest, options?: AxiosRequestConfig): AxiosPromise<UsersSetPhotoResponse> {
            return localVarFp.setPhoto(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually sets user presence.
         * @param {UsersApiSetPresenceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPresence(requestParameters: UsersApiSetPresenceRequest, options?: AxiosRequestConfig): AxiosPromise<UsersSetPresenceResponse> {
            return localVarFp.setPresence(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the profile information for a user.
         * @param {UsersApiSetProfileInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfileInfo(requestParameters: UsersApiSetProfileInfoRequest, options?: AxiosRequestConfig): AxiosPromise<UsersprofileSetProfileInfoResponse> {
            return localVarFp.setProfileInfo(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for conversations operation in UsersApi.
 * @export
 * @interface UsersApiConversationsRequest
 */
export type UsersApiConversationsRequest = {
    
    /**
    * Authentication token. Requires scope: `conversations:read`
    * @type {string}
    * @memberof UsersApiConversations
    */
    readonly token?: string
    
    /**
    * Browse conversations by a specific user ID\'s membership. Non-public channels are restricted to those where the calling user shares membership.
    * @type {string}
    * @memberof UsersApiConversations
    */
    readonly user?: string
    
    /**
    * Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
    * @type {string}
    * @memberof UsersApiConversations
    */
    readonly types?: string
    
    /**
    * Set to `true` to exclude archived channels from the list
    * @type {boolean}
    * @memberof UsersApiConversations
    */
    readonly excludeArchived?: boolean
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn\'t been reached. Must be an integer no larger than 1000.
    * @type {number}
    * @memberof UsersApiConversations
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof UsersApiConversations
    */
    readonly cursor?: string
    
}

/**
 * Request parameters for deletePhoto operation in UsersApi.
 * @export
 * @interface UsersApiDeletePhotoRequest
 */
export type UsersApiDeletePhotoRequest = {
    
    /**
    * Authentication token. Requires scope: `users.profile:write`
    * @type {string}
    * @memberof UsersApiDeletePhoto
    */
    readonly token: string
    
} & UsersDeletePhotoRequest

/**
 * Request parameters for getPresence operation in UsersApi.
 * @export
 * @interface UsersApiGetPresenceRequest
 */
export type UsersApiGetPresenceRequest = {
    
    /**
    * Authentication token. Requires scope: `users:read`
    * @type {string}
    * @memberof UsersApiGetPresence
    */
    readonly token: string
    
    /**
    * User to get presence info on. Defaults to the authed user.
    * @type {string}
    * @memberof UsersApiGetPresence
    */
    readonly user?: string
    
}

/**
 * Request parameters for getProfileInfo operation in UsersApi.
 * @export
 * @interface UsersApiGetProfileInfoRequest
 */
export type UsersApiGetProfileInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `users.profile:read`
    * @type {string}
    * @memberof UsersApiGetProfileInfo
    */
    readonly token: string
    
    /**
    * Include labels for each ID in custom profile fields
    * @type {boolean}
    * @memberof UsersApiGetProfileInfo
    */
    readonly includeLabels?: boolean
    
    /**
    * User to retrieve profile info for
    * @type {string}
    * @memberof UsersApiGetProfileInfo
    */
    readonly user?: string
    
}

/**
 * Request parameters for identity operation in UsersApi.
 * @export
 * @interface UsersApiIdentityRequest
 */
export type UsersApiIdentityRequest = {
    
    /**
    * Authentication token. Requires scope: `identity.basic`
    * @type {string}
    * @memberof UsersApiIdentity
    */
    readonly token?: string
    
}

/**
 * Request parameters for info operation in UsersApi.
 * @export
 * @interface UsersApiInfoRequest
 */
export type UsersApiInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `users:read`
    * @type {string}
    * @memberof UsersApiInfo
    */
    readonly token: string
    
    /**
    * Set this to `true` to receive the locale for this user. Defaults to `false`
    * @type {boolean}
    * @memberof UsersApiInfo
    */
    readonly includeLocale?: boolean
    
    /**
    * User to get info on
    * @type {string}
    * @memberof UsersApiInfo
    */
    readonly user?: string
    
}

/**
 * Request parameters for list operation in UsersApi.
 * @export
 * @interface UsersApiListRequest
 */
export type UsersApiListRequest = {
    
    /**
    * Authentication token. Requires scope: `users:read`
    * @type {string}
    * @memberof UsersApiList
    */
    readonly token?: string
    
    /**
    * The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn\'t been reached. Providing no `limit` value will result in Slack attempting to deliver you the entire result set. If the collection is too large you may experience `limit_required` or HTTP 500 errors.
    * @type {number}
    * @memberof UsersApiList
    */
    readonly limit?: number
    
    /**
    * Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request\'s `response_metadata`. Default value fetches the first \"page\" of the collection. See [pagination](https://slack.dev) for more detail.
    * @type {string}
    * @memberof UsersApiList
    */
    readonly cursor?: string
    
    /**
    * Set this to `true` to receive the locale for users. Defaults to `false`
    * @type {boolean}
    * @memberof UsersApiList
    */
    readonly includeLocale?: boolean
    
}

/**
 * Request parameters for lookupByEmail operation in UsersApi.
 * @export
 * @interface UsersApiLookupByEmailRequest
 */
export type UsersApiLookupByEmailRequest = {
    
    /**
    * Authentication token. Requires scope: `users:read.email`
    * @type {string}
    * @memberof UsersApiLookupByEmail
    */
    readonly token: string
    
    /**
    * An email address belonging to a user in the workspace
    * @type {string}
    * @memberof UsersApiLookupByEmail
    */
    readonly email: string
    
}

/**
 * Request parameters for setActive operation in UsersApi.
 * @export
 * @interface UsersApiSetActiveRequest
 */
export type UsersApiSetActiveRequest = {
    
    /**
    * Authentication token. Requires scope: `users:write`
    * @type {string}
    * @memberof UsersApiSetActive
    */
    readonly token: string
    
}

/**
 * Request parameters for setPhoto operation in UsersApi.
 * @export
 * @interface UsersApiSetPhotoRequest
 */
export type UsersApiSetPhotoRequest = {
    
    /**
    * Authentication token. Requires scope: `users.profile:write`
    * @type {string}
    * @memberof UsersApiSetPhoto
    */
    readonly token: string
    
    /**
    * Width/height of crop box (always square)
    * @type {string}
    * @memberof UsersApiSetPhoto
    */
    readonly cropW?: string
    
    /**
    * X coordinate of top-left corner of crop box
    * @type {string}
    * @memberof UsersApiSetPhoto
    */
    readonly cropX?: string
    
    /**
    * Y coordinate of top-left corner of crop box
    * @type {string}
    * @memberof UsersApiSetPhoto
    */
    readonly cropY?: string
    
    /**
    * File contents via `multipart/form-data`.
    * @type {string}
    * @memberof UsersApiSetPhoto
    */
    readonly image?: string
    
} & UsersSetPhotoRequest

/**
 * Request parameters for setPresence operation in UsersApi.
 * @export
 * @interface UsersApiSetPresenceRequest
 */
export type UsersApiSetPresenceRequest = {
    
    /**
    * Authentication token. Requires scope: `users:write`
    * @type {string}
    * @memberof UsersApiSetPresence
    */
    readonly token: string
    
    /**
    * Either `auto` or `away`
    * @type {string}
    * @memberof UsersApiSetPresence
    */
    readonly presence: string
    
} & UsersSetPresenceRequest

/**
 * Request parameters for setProfileInfo operation in UsersApi.
 * @export
 * @interface UsersApiSetProfileInfoRequest
 */
export type UsersApiSetProfileInfoRequest = {
    
    /**
    * Authentication token. Requires scope: `users.profile:write`
    * @type {string}
    * @memberof UsersApiSetProfileInfo
    */
    readonly token: string
    
    /**
    * Name of a single key to set. Usable only if `profile` is not passed.
    * @type {string}
    * @memberof UsersApiSetProfileInfo
    */
    readonly name?: string
    
    /**
    * Collection of key:value pairs presented as a URL-encoded JSON hash. At most 50 fields may be set. Each field name is limited to 255 characters.
    * @type {string}
    * @memberof UsersApiSetProfileInfo
    */
    readonly profile?: string
    
    /**
    * ID of user to change. This argument may only be specified by team admins on paid teams.
    * @type {string}
    * @memberof UsersApiSetProfileInfo
    */
    readonly user?: string
    
    /**
    * Value to set a single key to. Usable only if `profile` is not passed.
    * @type {string}
    * @memberof UsersApiSetProfileInfo
    */
    readonly value?: string
    
} & UsersprofileSetProfileInfoRequest

/**
 * UsersApiGenerated - object-oriented interface
 * @export
 * @class UsersApiGenerated
 * @extends {BaseAPI}
 */
export class UsersApiGenerated extends BaseAPI {
    /**
     * List conversations the calling user may access.
     * @param {UsersApiConversationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public conversations(requestParameters: UsersApiConversationsRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).conversations(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the user profile photo
     * @param {UsersApiDeletePhotoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public deletePhoto(requestParameters: UsersApiDeletePhotoRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deletePhoto(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets user presence information.
     * @param {UsersApiGetPresenceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getPresence(requestParameters: UsersApiGetPresenceRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getPresence(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a user\'s profile information.
     * @param {UsersApiGetProfileInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getProfileInfo(requestParameters: UsersApiGetProfileInfoRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getProfileInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user\'s identity.
     * @param {UsersApiIdentityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public identity(requestParameters: UsersApiIdentityRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).identity(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets information about a user.
     * @param {UsersApiInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public info(requestParameters: UsersApiInfoRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).info(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all users in a Slack team.
     * @param {UsersApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public list(requestParameters: UsersApiListRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a user with an email address.
     * @param {UsersApiLookupByEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public lookupByEmail(requestParameters: UsersApiLookupByEmailRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).lookupByEmail(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marked a user as active. Deprecated and non-functional.
     * @param {UsersApiSetActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public setActive(requestParameters: UsersApiSetActiveRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setActive(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the user profile photo
     * @param {UsersApiSetPhotoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public setPhoto(requestParameters: UsersApiSetPhotoRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setPhoto(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually sets user presence.
     * @param {UsersApiSetPresenceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public setPresence(requestParameters: UsersApiSetPresenceRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setPresence(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the profile information for a user.
     * @param {UsersApiSetProfileInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public setProfileInfo(requestParameters: UsersApiSetProfileInfoRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).setProfileInfo(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
